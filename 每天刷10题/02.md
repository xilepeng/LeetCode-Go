
1. [160. ç›¸äº¤é“¾è¡¨](#160-ç›¸äº¤é“¾è¡¨)
2. [46. å…¨æ’åˆ—](#46-å…¨æ’åˆ—)
3. [47. å…¨æ’åˆ— II  è¡¥å……](#47-å…¨æ’åˆ—-ii--è¡¥å……)
4. [54. èºæ—‹çŸ©é˜µ](#54-èºæ—‹çŸ©é˜µ)
5. [23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](#23-åˆå¹¶kä¸ªå‡åºé“¾è¡¨)
6. [142. ç¯å½¢é“¾è¡¨ II](#142-ç¯å½¢é“¾è¡¨-ii)
7. [92. åè½¬é“¾è¡¨ II](#92-åè½¬é“¾è¡¨-ii)
8. [415. å­—ç¬¦ä¸²ç›¸åŠ ](#415-å­—ç¬¦ä¸²ç›¸åŠ )
9. [300. æœ€é•¿é€’å¢å­åºåˆ—](#300-æœ€é•¿é€’å¢å­åºåˆ—)
10. [42. æ¥é›¨æ°´](#42-æ¥é›¨æ°´)
11. [143. é‡æ’é“¾è¡¨](#143-é‡æ’é“¾è¡¨)
12. [124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](#124-äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ)
13. [94. äºŒå‰æ ‘çš„ä¸­åºéå†](#94-äºŒå‰æ ‘çš„ä¸­åºéå†)
14. [704. äºŒåˆ†æŸ¥æ‰¾](#704-äºŒåˆ†æŸ¥æ‰¾)
15. [232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](#232-ç”¨æ ˆå®ç°é˜Ÿåˆ—)
16. [199. äºŒå‰æ ‘çš„å³è§†å›¾](#199-äºŒå‰æ ‘çš„å³è§†å›¾)
17. [70. çˆ¬æ¥¼æ¢¯](#70-çˆ¬æ¥¼æ¢¯)
18. [19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](#19-åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬-n-ä¸ªç»“ç‚¹)
19. [148. æ’åºé“¾è¡¨](#148-æ’åºé“¾è¡¨)
20. [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](#4-å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°)
21. [56. åˆå¹¶åŒºé—´](#56-åˆå¹¶åŒºé—´)

---


## [160. ç›¸äº¤é“¾è¡¨](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	A, B := headA, headB
	for A != B {
		if A != nil {
			A = A.Next
		} else {
			A = headB
		}
		if B != nil {
			B = B.Next
		} else {
			B = headA
		}
	}
	return A
}
```

## [46. å…¨æ’åˆ—](https://leetcode-cn.com/problems/permutations/)

```go
func permute(nums []int) (res [][]int) {
	n := len(nums)
	var dfs func(int)
	dfs = func(first int) {
		if first == n { // æ‰€æœ‰æ•°éƒ½å¡«å®Œäº†
			res = append(res, append([]int{}, nums...))
		}
		for i := first; i < n; i++ {
			nums[first], nums[i] = nums[i], nums[first] // åŠ¨æ€ç»´æŠ¤æ•°ç»„
			dfs(first + 1)                              // ç»§ç»­é€’å½’å¡«ä¸‹ä¸€ä¸ªæ•°
			nums[first], nums[i] = nums[i], nums[first] // æ’¤é”€æ“ä½œ
		}
	}
	dfs(0)
	return
}
```

```go
func permute(nums []int) (res [][]int) {
	used, path, n := make(map[int]bool, len(nums)), []int{}, len(nums)
	var dfs func(int)
	dfs = func(pos int) {
		for i := 0; i < n; i++ {
			if len(path) == n {
				res = append(res, append([]int{}, path...))
				return
			}
			if !used[i] {
				used[i] = true
				path = append(path, nums[i])
				dfs(pos + 1)
				path = path[:len(path)-1]
				used[i] = false
			}
		}
	}
	dfs(0)
	return
}
```

## [47. å…¨æ’åˆ— II](https://leetcode-cn.com/problems/permutations-ii/)  è¡¥å……

```go

```


## [54. èºæ—‹çŸ©é˜µ](https://leetcode-cn.com/problems/spiral-matrix/)

**æ–¹æ³•ä¸€ï¼šéå†åˆ°åº•**

```go
func spiralOrder(matrix [][]int) (res []int) {
    if len(matrix) == 0 { return []int{} }
    top, right, bottom, left := 0, len(matrix[0])-1, len(matrix)-1, 0
    length := len(matrix)*len(matrix[0])
    for len(res) != length {
        for i := left; i <= right; i++ {res = append(res, matrix[top][i])}
        top ++
        for i := top; i <= bottom; i++ {res = append(res, matrix[i][right])}
        right --
        if len(res) == length { break}
        for i := right; i >= left; i-- {res = append(res, matrix[bottom][i])}
        bottom --
        for i := bottom; i >= top; i-- {res = append(res, matrix[i][left])}
        left ++
    }
    return 
}
```

```go
func spiralOrder(matrix [][]int) (res []int) {
    if len(matrix) == 0 { return []int{}}
    top, right, bottom, left := 0, len(matrix[0])-1, len(matrix)-1, 0
    for left <= right && top <= bottom {
        for i := left; i <= right; i++ {res = append(res, matrix[top][i])}
        top ++
        for i := top; i <= bottom; i++ {res = append(res, matrix[i][right])}
        right --
        if left > right || top > bottom {break}  // éå†å®Œæˆè¦ä¹ˆå‘ç”Ÿåœ¨éå†å®Œâ€œä¸Šè¾¹â€ï¼Œè¦ä¹ˆå‘ç”Ÿåœ¨éå†å®Œâ€œå³è¾¹â€
        for i := right; i >= left; i-- {res = append(res, matrix[bottom][i])}
        bottom --
        for i := bottom; i >= top; i-- {res = append(res, matrix[i][left])}
        left ++
    }
    return
}
```
**æ–¹æ³•äºŒï¼šéå†åˆ°æœ€åä¸€ä¸ªå‰ï¼Œä¸åŒ…å«æœ€åä¸€ä¸ª**

```go
func spiralOrder(matrix [][]int) (res []int) {
	if len(matrix) == 0 {
		return []int{}
	}
	top, right, bottom, left := 0, len(matrix[0])-1, len(matrix)-1, 0
	for top < bottom && left < right {
		for i := left; i < right; i++ {res = append(res, matrix[top][i]) }
		for i := top; i < bottom; i++ {res = append(res, matrix[i][right])}
		for i := right; i > left; i-- {res = append(res, matrix[bottom][i])}
		for i := bottom; i > top; i-- {res = append(res, matrix[i][left])}
		top++
		right--
		bottom--
		left++
	}
	if top == bottom {
		for i := left; i <= right; i++ {res = append(res, matrix[top][i]) }
	}else if left == right {
		for i := top; i <= bottom; i++ {res = append(res, matrix[i][right])}
	}
	return
}
```

## [23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeKLists(lists []*ListNode) *ListNode {
	n := len(lists)
	if n == 0 {
		return nil
	}
	if n == 1 {
		return lists[0]
	}
	mid := n >> 1
	left, right := mergeKLists(lists[:mid]), mergeKLists(lists[mid:]) // åˆ†
	return merge2List(left, right)                                    // æ²»
}
func merge2List(l1, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	if l1.Val < l2.Val {
		l1.Next = merge2List(l1.Next, l2)
		return l1
	} else {
		l2.Next = merge2List(l1, l2.Next)
		return l2
	}
}
```

## [142. ç¯å½¢é“¾è¡¨ II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
		if slow == fast {
			fast = head
			for slow != fast {
				slow, fast = slow.Next, fast.Next
			}
			return fast
		}
	}
	return nil
}
```


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
	slow, ok := hasCycle(head)
	if !ok {
		return nil
	}
	fast := head
	for slow != fast {
		slow = slow.Next
		fast = fast.Next
	}
	return fast
}
func hasCycle(head *ListNode) (*ListNode, bool) {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
		if slow == fast {
			return slow, true
		}
	}
	return nil, false
}
```



## [92. åè½¬é“¾è¡¨ II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

**æ–¹æ³•ä¸€ï¼šåŒæŒ‡é’ˆ**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, left int, right int) *ListNode {
	dummy := &ListNode{Next: head}
	pre := dummy
	for i := 0; i < left-1; i++ {
		pre = pre.Next
	}
	prev, curr := pre.Next, pre.Next.Next
	for i := 0; i < right-left; i++ {
		next := curr.Next
		curr.Next = prev
		prev = curr
		curr = next
	}
	pre.Next.Next = curr
	pre.Next = prev
	return dummy.Next
}
```


**æ–¹æ³•äºŒï¼šå¤´æ’æ³•**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, left int, right int) *ListNode {
	dummy := &ListNode{Next: head}
	pre := dummy
	for i := 0; i < left-1; i++ {
		pre = pre.Next
	}
	curr := pre.Next
	for i := 0; i < right-left; i++ {
		next := curr.Next
		curr.Next = next.Next // ğŸ“ 
		next.Next = pre.Next
		pre.Next = next
	}
	return dummy.Next
}
```

**æ–¹æ³•ä¸‰ï¼šç©¿é’ˆå¼•çº¿**

```go

```

## [415. å­—ç¬¦ä¸²ç›¸åŠ ](https://leetcode-cn.com/problems/add-strings/)


```go
func addStrings(num1 string, num2 string) string {
	res, carry := "", 0
	for i, j := len(num1)-1, len(num2)-1; i >= 0 || j >= 0 || carry > 0; i, j = i-1, j-1 {
		var x, y int
		if i >= 0 {
			x = int(num1[i] - '0')
		}
		if j >= 0 {
			y = int(num2[j] - '0')
		}
		tmp := x + y + carry
		res = strconv.Itoa(tmp%10) + res
		carry = tmp / 10
	}
	return res
}
```


## [300. æœ€é•¿é€’å¢å­åºåˆ—](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```go
func lengthOfLIS(nums []int) int {
	dp := []int{} // ç»´æŠ¤å•è°ƒé€’å¢æ•°ç»„ sorted
	for _, x := range nums {
		// åœ¨é€’å¢é¡ºåºçš„æ•°ç»„dpä¸­æœç´¢xï¼Œè¿”å›xçš„ç´¢å¼•ã€‚å¦‚æœæŸ¥æ‰¾ä¸åˆ°ï¼Œè¿”å›å€¼æ˜¯xåº”è¯¥æ’å…¥dpçš„ä½ç½®
		i := sort.SearchInts(dp, x) // min_index
		if i == len(dp) {           // dp ä¸­ä¸å­˜åœ¨ x
			dp = append(dp, x)
		} else {
			dp[i] = x // dp ä¸­å­˜åœ¨ xï¼Œæ›´æ–°
		}
	}
	return len(dp)
}
```


## [42. æ¥é›¨æ°´](https://leetcode-cn.com/problems/trapping-rain-water/) 

```go
func trap(height []int) (res int) {
	left, right := 0, len(height)-1
	leftMax, rightMax := 0, 0
	for left < right {
		leftMax = max(leftMax, height[left])
		rightMax = max(rightMax, height[right])
		if height[left] < height[right] {
			res += leftMax - height[left]
			left++
		} else {
			res += rightMax - height[right]
			right--
		}
	}
	return
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

## [143. é‡æ’é“¾è¡¨](https://leetcode-cn.com/problems/reorder-list/)


```go
 *
 * [143] é‡æ’é“¾è¡¨
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reorderList(head *ListNode) {
	if head == nil {
		return
	}
	mid := middleNode(head)
	l1, l2 := head, mid.Next
	mid.Next = nil
	l2 = reverse(l2)
	mergeList(l1, l2)
}
func middleNode(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast.Next != nil && fast.Next.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
	}
	return slow
}
func reverse(head *ListNode) *ListNode {
	var prev *ListNode
	curr := head
	for curr != nil {
		next := curr.Next
		curr.Next = prev
		prev = curr
		curr = next
	}
	return prev
}
func mergeList(l1, l2 *ListNode) {
	var l1Tmp, l2Tmp *ListNode
	for l1 != nil && l2 != nil {
		l1Tmp, l2Tmp = l1.Next, l2.Next
		l1.Next = l2
		l1 = l1Tmp
		l2.Next = l1
		l2 = l2Tmp
	}
}
```


---







## [124. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxPathSum(root *TreeNode) int {
	maxSum := math.MinInt64
	var dfs func(*TreeNode) int
	dfs = func(node *TreeNode) int {
		if node == nil {
			return 0
		}
		left, right := max(dfs(node.Left), 0), max(dfs(node.Right), 0) // å·¦/å³å­æ ‘æä¾›çš„æœ€å¤§è·¯å¾„å’Œ
		maxSum = max(maxSum, node.Val+left+right)                      // å½“å‰å­æ ‘å†…éƒ¨çš„æœ€å¤§è·¯å¾„å’Œæ›´æ–°æœ€å¤§è·¯å¾„å’Œ
		return node.Val + max(left, right)                             // è¿”å›å½“å‰èŠ‚ç‚¹çš„æœ€å¤§è·¯å¾„å’Œ
	}
	dfs(root)
	return maxSum
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

[å‚è€ƒ1](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-leetcode-/)


[å‚è€ƒ2](https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/)


## [94. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) (res []int) {
	var dfs func(*TreeNode)
	dfs = func(root *TreeNode) {
		if root != nil {
			dfs(root.Left)
			res = append(res, root.Val)
			dfs(root.Right)
		}
	}
	dfs(root)
	return
}
```




## [704. äºŒåˆ†æŸ¥æ‰¾](https://leetcode-cn.com/problems/binary-search/) 


```go
func search(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + (high-low)>>1 // mid=(low+high)/2
		if nums[mid] < target {
			low = mid + 1
		} else if nums[mid] > target {
			high = mid - 1
		} else {
			return mid // nums[mid] == target
		}
	}
	return -1 // target æ²¡æ‰¾åˆ°
}
```

```go
func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)>>1
		if nums[mid] == target {
			return mid
		} else if nums[mid] < target {
			l = mid + 1
		} else {
			r = mid - 1
		}
	}
	return -1
}
```

## [232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](https://leetcode-cn.com/problems/implement-queue-using-stacks/)


```go
/*
 * @lc app=leetcode.cn id=232 lang=golang
 *
 * [232] ç”¨æ ˆå®ç°é˜Ÿåˆ—
 */

// @lc code=start
type MyQueue struct {
	inStack, outStack []int
}

func Constructor() MyQueue {
	return MyQueue{}
}

func (q *MyQueue) Push(x int) {
	q.inStack = append(q.inStack, x)
}

func (q *MyQueue) in2out() {
	for len(q.inStack) > 0 {
		q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])
		q.inStack = q.inStack[:len(q.inStack)-1]
	}
}

func (q *MyQueue) Pop() int {
	if len(q.outStack) == 0 {
		q.in2out()
	}
	x := q.outStack[len(q.outStack)-1]
	q.outStack = q.outStack[:len(q.outStack)-1]
	return x
}

func (q *MyQueue) Peek() int {
	if len(q.outStack) == 0 {
		q.in2out()
	}
	return q.outStack[0]
}

func (q *MyQueue) Empty() bool {
	return len(q.inStack) == 0 && len(q.outStack) == 0
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Peek();
 * param_4 := obj.Empty();
 */
// @lc code=end


```







## [199. äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode-cn.com/problems/binary-tree-right-side-view/)



```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) (res []int) {
	var dfs func(*TreeNode, int)
	dfs = func(node *TreeNode, level int) { // æ ¹å³å·¦
		if node == nil {
			return
		}
		if level == len(res) { // å¦‚æœä¸å­˜åœ¨å¯¹åº”æ·±åº¦çš„èŠ‚ç‚¹
			res = append(res, node.Val)
		}
		dfs(node.Right, level+1)
		dfs(node.Left, level+1)
	}
	dfs(root, 0)
	return
}
```




## [70. çˆ¬æ¥¼æ¢¯](https://leetcode-cn.com/problems/climbing-stairs/)

**æ–¹æ³•ä¸€ï¼šæ»šåŠ¨æ•°ç»„**

```go
func climbStairs(n int) int {
	p, q, r := 0, 0, 1
	for i := 1; i <= n; i++ {
		p = q
		q = r
		r = p + q
	}
	return r
}
```

**æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’**

```go
func climbStairs(n int) int {
	dp := make([]int, n+1)
	dp[0], dp[1] = 1, 1
	for i := 2; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}
```

**å‹ç¼©ç©ºé—´ï¼Œä¼˜åŒ–**

dp[i] åªä¸è¿‡å»çš„ä¸¤é¡¹ï¼šdp[i-1] å’Œ dp[i-2] æœ‰å…³ï¼Œæ²¡æœ‰å¿…è¦å­˜ä¸‹æ‰€æœ‰è®¡ç®—è¿‡çš„ dp é¡¹ã€‚ç”¨ä¸¤ä¸ªå˜é‡å»å­˜è¿™ä¸¤ä¸ªè¿‡å»çš„çŠ¶æ€å°±å¥½ã€‚

```go
func climbStairs(n int) int {
	prev, curr := 0, 1
	for i := 1; i <= n; i++ {
		next := prev + curr
		prev = curr
		curr = next
	}
	return curr
}
```


## [19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

**æ–¹æ³•ä¸€ï¼šåŒæŒ‡é’ˆ**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{0, head}
	first, second := head, dummy
	for i := 0; i < n; i++ {
		first = first.Next
	}
	for ; first != nil; first = first.Next {
		second = second.Next
	}
	second.Next = second.Next.Next
	return dummy.Next
}
```
**ä¼˜åŒ–**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{0, head}
	first, second := head, dummy
	for i := 0; first != nil; i++ {
		if i >= n {
			second = second.Next
		}
		first = first.Next
	}
	second.Next = second.Next.Next
	return dummy.Next
}
```

**æ–¹æ³•äºŒï¼šè®¡ç®—é“¾è¡¨é•¿åº¦**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{Next: head}
	prev, length := dummy, 0
	for ; head != nil; head = head.Next {
		length++
	}
	for i := 0; i < length-n; i++ {
		prev = prev.Next
	}
	prev.Next = prev.Next.Next
	return dummy.Next
}
```


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{Next: head}
	prev := dummy
	length := getLength(head)
	for i := 0; i < length-n; i++ {
		prev = prev.Next
	}
	prev.Next = prev.Next.Next
	return dummy.Next
}
func getLength(head *ListNode) (length int) {
	for ; head != nil; head = head.Next {
		length++
	}
	return
}
```



## [148. æ’åºé“¾è¡¨](https://leetcode-cn.com/problems/sort-list/)



```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func sortList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	slow, fast, preSlow := head, head, new(ListNode)
	for fast != nil && fast.Next != nil {
		preSlow = slow
		slow, fast = slow.Next, fast.Next.Next
	}
	preSlow.Next = nil
	left, right := sortList(head), sortList(slow)
	return merge2list(left, right)
}
func merge2list(l1, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	if l1.Val < l2.Val {
		l1.Next = merge2list(l1.Next, l2)
		return l1
	} else {
		l2.Next = merge2list(l1, l2.Next)
		return l2
	}
}
```


## [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)




## [56. åˆå¹¶åŒºé—´](https://leetcode-cn.com/problems/merge-intervals/)



```go
func merge(intervals [][]int) (res [][]int) {
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})
	prev := intervals[0]
	for i := 1; i < len(intervals); i++ {
		curr := intervals[i]
		if prev[1] < curr[0] { // æ— é‡åˆ
			res = append(res, prev)
			prev = curr
		} else { // æœ‰é‡åˆ
			prev[1] = max(prev[1], curr[1])
		}
	}
	res = append(res, prev) //åŠ å…¥æœ€åä¸€ç»„
	return
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```