
1. [âœ…æ‰‹æ’•å¿«é€Ÿæ’åº](#æ‰‹æ’•å¿«é€Ÿæ’åº)
2. [âœ…æ‰‹æ’•å½’å¹¶æ’åº](#æ‰‹æ’•å½’å¹¶æ’åº)
3. [âœ…æ‰‹æ’•å †æ’åº](#æ‰‹æ’•å †æ’åº)
4. [ğŸ“æ’å…¥æ’åº](#æ’å…¥æ’åº)
5. [ğŸ“å¸Œå°”æ’åº](#å¸Œå°”æ’åº)
6. [ğŸ“é€‰æ‹©æ’åº](#é€‰æ‹©æ’åº)
7. [ğŸ“å†’æ³¡æ’åº](#å†’æ³¡æ’åº)
8. [Counting Sort](#counting-sort)
9. [Bucket Sort](#bucket-sort)
10. [Radix Sort](#radix-sort)


## [âœ…æ‰‹æ’•å¿«é€Ÿæ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

**ç®€å†™**

``` go
func sortArray(A []int) []int {
	quickSort(A, 0, len(A)-1)
	return A
}

func quickSort(A []int, l, r int) {
	if l >= r {
		return
	}
	x := A[l+(r-l)>>1]
	i, j := l-1, r+1
	for i < j {
		for i++; A[i] < x; i++ {
		}
		for j--; A[j] > x; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	quickSort(A, l, j)
	quickSort(A, j+1, r)
}
```

```go
func sortArray(nums []int) []int {
	quickSort(nums, 0, len(nums)-1)
	return nums
}
func quickSort(A []int, l, r int) {
	if l >= r {
		return
	}
	piv_pos := partition(A, l, r)
	quickSort(A, l, piv_pos)
	quickSort(A, piv_pos+1, r)
}
func partition(A []int, l, r int) int {
	x := A[(l+r)/2]
	i, j := l-1, r+1
	for {
		for i++; A[i] < x; i++ {
		}
		for j--; A[j] > x; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		} else {
			break
		}
	}
	return j
}
```

**3æ•°ä¸­å€¼åˆ†å‰²ä¼˜åŒ–**

``` go
func sortArray(nums []int) []int {
	quickSort(nums, 0, len(nums)-1)
	return nums
}

func quickSort(A []int, l, r int) {
	if l >= r {
		return
	}
	piv_pos := partition(A, l, r)
	quickSort(A, l, piv_pos)
	quickSort(A, piv_pos+1, r)
}

func partition(A []int, l, r int) int {
	pivot := median3(A, l, r)
	i, j := l-1, r+1
	for i < j {
		for i++; A[i] < pivot; i++ {
		}
		for j--; A[j] > pivot; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	return j
}

// ä¸‰æ•°ä¸­å€¼åˆ†å‰²ï¼Œå‡å°‘ 5% è¿è¡Œæ—¶é—´
func median3(A []int, l, r int) int {
	mid := l + (r - l) >> 1
	if A[l] > A[mid] {
		A[l], A[mid] = A[mid], A[l]
	}
	if A[l] > A[r] {
		A[l], A[r] = A[r], A[l]
	}
	if A[mid] > A[r] {
		A[r], A[mid] = A[mid], A[r]
	}
	return A[mid] // A[l] <= A[mid] <= A[r]
}
```




## [âœ…æ‰‹æ’•å½’å¹¶æ’åº](https://leetcode.cn/problems/sort-an-tmparray/)

``` go
func sortArray(nums []int) []int {
	mergeSort(nums, 0, len(nums)-1)
	return nums
}

func merge1(A []int, start, mid, end int) {
	tmp := make([]int, end-start+1)
	i, j, k := start, mid+1, 0
	for i <= mid && j <= end {
		if A[i] < A[j] {
			tmp[k] = A[i]
			i++
		} else {
			tmp[k] = A[j]
			j++
		}
		k++
	}
	for i <= mid {
		tmp[k] = A[i]
		i++
		k++
	}
	for j <= end {
		tmp[k] = A[j]
		j++
		k++
	}
	for p := 0; p < k; p++ {
		A[start] = tmp[p]
		start++
	}
}

func merge2(A []int, start, mid, end int) {
	tmpArr := make([]int, end-start+1)
	i, j, k := start, mid+1, 0
	for p := start; p <= end; p++ {
		if j > end || (i <= mid && A[i] < A[j]) {
			tmpArr[k] = A[i]
			i++
		} else {
			tmpArr[k] = A[j]
			j++
		}
		k++
	}
	for p := 0; p < k; p++ {
		A[start] = tmpArr[p]
		start++
	}
}

func merge3(A []int, start, mid, end int) {
	tmpArr := make([]int, end-start+1)
	i, j, k := start, mid+1, 0
	for p := start; p <= end; p++ {
		if i > mid {
			tmpArr[k] = A[j]
			j++
		} else if j > end {
			tmpArr[k] = A[i]
			i++
		} else if A[i] <= A[j] {
			tmpArr[k] = A[i]
			i++
		} else {
			tmpArr[k] = A[j]
			j++
		}
		k++
	}
	for p := 0; p < k; p++ {
		A[start] = tmpArr[p]
		start++
	}
}

func mergeSort(A []int, start, end int) {
	if start >= end {
		return
	}
	mid := start + (end-start)>>1 // mid := (start + end) / 2
	mergeSort(A, start, mid)
	mergeSort(A, mid+1, end)
	// merge1(A, start, mid, end)
	// merge2(A, start, mid, end)
	merge3(A, start, mid, end)
}
```


## [âœ…æ‰‹æ’•å †æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

``` go
func sortArray(A []int) []int {
	heapSort(A)
	return A
}

// åœ¨å¤§æ ¹å †ä¸­ã€æœ€å¤§å…ƒç´ æ€»åœ¨æ ¹ä¸Šï¼Œå †æ’åºä½¿ç”¨å †çš„è¿™ä¸ªå±æ€§è¿›è¡Œæ’åº
func heapSort(A []int) {
	heapSize := len(A) - 1
	buildMaxHeap(A, heapSize) // A[0]ä¸ºå †é¡¶
	for i := heapSize; i > 0; i-- {
		A[0], A[i] = A[i], A[0] // äº¤æ¢å †é¡¶å…ƒç´  A[0] ä¸å †åº•å…ƒç´  A[i]ï¼Œæœ€å¤§å€¼ A[0] æ”¾ç½®åœ¨æ•°ç»„æœ«å°¾
		heapSize--              // åˆ é™¤å †é¡¶å…ƒç´  A[0]
		// maxHeapify1(A, 0, heapSize) // å †é¡¶å…ƒç´  A[0] å‘ä¸‹è°ƒæ•´
		maxHeapify(A, 0, heapSize) // å †é¡¶å…ƒç´  A[0] å‘ä¸‹è°ƒæ•´
	}
}

// å»ºå † O(n)
func buildMaxHeap(A []int, heapSize int) {
	for i := heapSize >> 1; i >= 0; i-- { // heapSize / 2 åé¢éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œä¸éœ€è¦å‘ä¸‹è°ƒæ•´
		maxHeapify(A, i, heapSize)
	}
}

// è¿­ä»£: è°ƒæ•´å¤§æ ¹å † O(n)
func maxHeapify(A []int, i, heapSize int) {
	for i<<1+1 <= heapSize { // i*2+1
		lson, rson, large := i<<1+1, i<<1+2, i
		if lson <= heapSize && A[large] < A[lson] {
			large = lson
		}
		if rson <= heapSize && A[large] < A[rson] {
			large = rson
		}
		if large != i {
			A[i], A[large] = A[large], A[i]
			i = large
		} else {
			break
		}
	}
}

// é€’å½’: è°ƒæ•´å¤§æ ¹å † O(nlogn)
func maxHeapify1(A []int, i, heapSize int) {
	lson, rson, largest := i<<1+1, i<<1+2, i      // i*2+1, i*2+2
	if lson <= heapSize && A[largest] < A[lson] { // å·¦å„¿å­å­˜åœ¨å¹¶å¤§äºæ ¹
		largest = lson
	}
	if rson <= heapSize && A[largest] < A[rson] { // å³å„¿å­å­˜åœ¨å¹¶å¤§äºæ ¹
		largest = rson
	}
	if i != largest { // æ‰¾åˆ°å·¦å³å„¿å­çš„æœ€å¤§å€¼
		A[i], A[largest] = A[largest], A[i] // å †é¡¶è°ƒæ•´ä¸ºæœ€å¤§å€¼
		maxHeapify1(A, largest, heapSize)   // é€’å½’è°ƒæ•´å­æ ‘
	}
}
```

## [ğŸ“æ’å…¥æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)


``` go

```

## [ğŸ“å¸Œå°”æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

``` go

```

## [ğŸ“é€‰æ‹©æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

``` go

```


## [ğŸ“å†’æ³¡æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

``` go

```

## [Counting Sort](https://www.hackerearth.com/practice/algorithms/sorting/counting-sort/tutorial/)

``` go

```


## [Bucket Sort](https://www.hackerearth.com/practice/algorithms/sorting/bucket-sort/tutorial/)

``` go

```

## [Radix Sort](https://www.hackerearth.com/practice/algorithms/sorting/radix-sort/tutorial/)


``` go

```