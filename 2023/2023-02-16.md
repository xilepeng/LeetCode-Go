
1. [14. æœ€é•¿å…¬å…±å‰ç¼€](#14-æœ€é•¿å…¬å…±å‰ç¼€)
2. [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](#34-åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®)
3. [226. ç¿»è½¬äºŒå‰æ ‘](#226-ç¿»è½¬äºŒå‰æ ‘)
4. [128. æœ€é•¿è¿ç»­åºåˆ—](#128-æœ€é•¿è¿ç»­åºåˆ—)
5. [162. å¯»æ‰¾å³°å€¼](#162-å¯»æ‰¾å³°å€¼)
6. [62. ä¸åŒè·¯å¾„](#62-ä¸åŒè·¯å¾„)
7. [695. å²›å±¿çš„æœ€å¤§é¢ç§¯](#695-å²›å±¿çš„æœ€å¤§é¢ç§¯)
8. [227. åŸºæœ¬è®¡ç®—å™¨ II](#227-åŸºæœ¬è®¡ç®—å™¨-ii)
9. [83. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ](#83-åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ )
10. [è¡¥å……é¢˜6. æ‰‹æ’•å †æ’åº 912. æ’åºæ•°ç»„](#è¡¥å……é¢˜6-æ‰‹æ’•å †æ’åº-912-æ’åºæ•°ç»„)


## [14. æœ€é•¿å…¬å…±å‰ç¼€](https://leetcode-cn.com/problems/longest-common-prefix/)

**æ–¹æ³•ä¸€ï¼šçºµå‘æ‰«æ**
ä»å‰å¾€åéå†æ‰€æœ‰å­—ç¬¦ä¸²çš„æ¯ä¸€åˆ—ï¼Œæ¯”è¾ƒç›¸åŒåˆ—ä¸Šçš„å­—ç¬¦æ˜¯å¦ç›¸åŒï¼Œ
- å¦‚æœç›¸åŒåˆ™ç»§ç»­å¯¹ä¸‹ä¸€åˆ—è¿›è¡Œæ¯”è¾ƒï¼Œ
- å¦‚æœä¸ç›¸åŒåˆ™å½“å‰åˆ—ä¸å†å±äºå…¬å…±å‰ç¼€ï¼Œå½“å‰åˆ—ä¹‹å‰çš„éƒ¨åˆ†ä¸ºæœ€é•¿å…¬å…±å‰ç¼€ã€‚

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i := 0; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i == len(strs[j]) || strs[j][i] != strs[0][i] {
                return strs[0][:i]
            }
        }
    }
    return strs[0]
}
```

```go
func longestCommonPrefix(strs []string) string {
	prefix := strs[0]
	for i := 1; i < len(strs); i++ {
		for j := 0; j < len(prefix); j++ {
			if len(strs[i]) <= j || strs[i][j] != prefix[j] {
				prefix = prefix[0:j]
				break // å¦‚æœä¸ä¸­æ–­ï¼Œj++åä¼šè¶Šç•Œ
			}
		}
	}
	return prefix
}
```


## [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)



```go
func searchRange(nums []int, target int) []int {
	start, end := findFirst(nums, target), findLast(nums, target)
	return []int{start, end}
}
// äºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä¸ target ç›¸ç­‰çš„å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(logn)
func findFirst(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + (high-low)>>1
		if nums[mid] < target {
			low = mid + 1
		} else if nums[mid] > target {
			high = mid - 1
		} else {
			if mid == 0 || nums[mid-1] != target { // æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ target ç›¸ç­‰çš„å…ƒç´ 
				return mid
			}
			high = mid - 1
		}
	}
	return -1
}
// äºŒåˆ†æŸ¥æ‰¾æœ€åä¸€ä¸ªä¸ target ç›¸ç­‰çš„å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(logn)
func findLast(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + (high-low)>>1
		if nums[mid] < target {
			low = mid + 1
		} else if nums[mid] > target {
			high = mid - 1
		} else {
			if mid == len(nums)-1 || nums[mid+1] != target { // æ‰¾åˆ°æœ€åä¸€ä¸ªä¸ target ç›¸ç­‰çš„å…ƒç´ 
				return mid
			}
			low = mid + 1
		}
	}
	return -1
}
```



```go
func searchRange(nums []int, target int) []int {
	start, end := findFirst(nums, target), findLast(nums, target)
	return []int{start, end}
}

func findFirst(nums []int, target int) int {
	low, high, start := 0, len(nums)-1, -1
	for low <= high {
		mid := low + (high-low)>>1
		if nums[mid] >= target {
			high = mid - 1
		} else {
			low = mid + 1
		}
		if nums[mid] == target {
			start = mid
		}
	}
	return start
}

func findLast(nums []int, target int) int {
	low, high, end := 0, len(nums)-1, -1
	for low <= high {
		mid := low + (high-low)>>1
		if nums[mid] <= target {
			low = mid + 1
		} else {
			high = mid - 1
		}
		if nums[mid] == target {
			end = mid
		}
	}
	return end
}
```


## [226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode-cn.com/problems/invert-binary-tree/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	invertTree(root.Left)                         // ç¿»è½¬å·¦å­æ ‘
	invertTree(root.Right)                        // ç¿»è½¬å³å­æ ‘ (å…¥æ ˆï¼šå‹æ ˆå‹åˆ°åº•éƒ¨)
	root.Left, root.Right = root.Right, root.Left // äº¤æ¢ï¼ˆå‡ºæ ˆï¼šè‡ªåº•å‘ä¸Šï¼‰
	return root
}
```

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	root.Left, root.Right = root.Right, root.Left // äº¤æ¢å·¦å³å­æ ‘
	invertTree(root.Left)                         // ç¿»è½¬å·¦å­æ ‘
	invertTree(root.Right)                        // ç¿»è½¬å³å­æ ‘ 
	return root
}
```


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	q := []*TreeNode{root}
	for len(q) > 0 {
		node := q[0]                                  // å–é˜Ÿé¦–
		q = q[1:]                                     // é˜Ÿé¦–å…ƒç´ å‡ºé˜Ÿ
		node.Left, node.Right = node.Right, node.Left // ç¿»è½¬å·¦å³å­æ ‘
		if node.Left != nil {
			q = append(q, node.Left)
		}
		if node.Right != nil {
			q = append(q, node.Right)
		}
	}
	return root
}
```


# [128. æœ€é•¿è¿ç»­åºåˆ—](https://leetcode-cn.com/problems/longest-consecutive-sequence/)ğŸ–Œ



**æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨**

```go
func longestConsecutive(nums []int) int {
	numSet, longgest := map[int]bool{}, 0
	for _, num := range nums {
		numSet[num] = true // æ ‡è®° nums æ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ éƒ½å­˜åœ¨
	}
	for _, num := range nums {
		if !numSet[num-1] { // å¦‚æœ num æ²¡æœ‰å‰é©±æ•°ï¼ˆå·¦é‚»å±…ï¼‰num-1
			currNum, currLonggest := num, 1
			for numSet[currNum+1] { // æšä¸¾æ•°ç»„ä¸­çš„æ¯ä¸ªæ•° xï¼Œè€ƒè™‘ä»¥å…¶ä¸ºèµ·ç‚¹ï¼Œä¸æ–­å°è¯•åŒ¹é… x+1,x+2,â‹¯ æ˜¯å¦å­˜åœ¨
				currNum++      // æšä¸¾è¿ç»­çš„ä¸‹ä¸€ä¸ªæ•°
				currLonggest++ // å½“å‰æœ€é•¿è¿ç»­é•¿åº¦é€’å¢
			}
			if longgest < currLonggest { // è®¡ç®—æœ€å¤§é•¿åº¦
				longgest = currLonggest
			}
		}
	}
	return longgest
}
```

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n ä¸ºæ•°ç»„çš„é•¿åº¦ã€‚å…·ä½“åˆ†æå·²åœ¨ä¸Šé¢æ­£æ–‡ä¸­ç»™å‡ºã€‚

- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚å“ˆå¸Œè¡¨å­˜å‚¨æ•°ç»„ä¸­æ‰€æœ‰çš„æ•°éœ€è¦ O(n) çš„ç©ºé—´ã€‚



[å‚è€ƒåœ°å€](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/276931/zui-chang-lian-xu-xu-lie-by-leetcode-solution/?languageTags=golang)


```go
func longestConsecutive(nums []int) (res int) {
	numSet := make(map[int]bool, len(nums))
	for _, num := range nums {
		numSet[num] = true
	}
	for num, _ := range numSet {
		if !numSet[num-1] {
			x := num + 1
			for numSet[x] {
				x++
			}
			if res < x-num {
				res = x - num
			}
		}
	}
	return
}
```

## [162. å¯»æ‰¾å³°å€¼](https://leetcode-cn.com/problems/find-peak-element/)

**äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–**

```go
func findPeakElement(nums []int) int {
	low, high := 0, len(nums)-1
	for low < high {
		mid := low + (high-low)>>1
		if nums[mid] > nums[mid+1] { // å¦‚æœ mid è¾ƒå¤§ï¼Œåˆ™å·¦ä¾§å­˜åœ¨å³°å€¼ï¼Œhigh = m
			high = mid
		} else { // å¦‚æœ mid + 1 è¾ƒå¤§ï¼Œåˆ™å³ä¾§å­˜åœ¨å³°å€¼ï¼Œlow = mid + 1
			low = mid + 1
		}
	}
	return low // low == high
}
```


- æ—¶é—´å¤æ‚åº¦ï¼šO(logn)ï¼Œå…¶ä¸­ nnn æ˜¯æ•°ç»„ nums çš„é•¿åº¦ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚


2023-02-17 10:50:59
---

## [62. ä¸åŒè·¯å¾„](https://leetcode.cn/problems/unique-paths/)
**æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’**
![](images/62-0.png)

```go
func uniquePaths(m int, n int) int {
	dp := make([][]int, m) // å®šä¹‰äºŒç»´æ•°ç»„
	for i := 0; i < m; i++ {
		dp[i] = make([]int, n)
	}
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if i == 0 || j == 0 {
				dp[i][j] = 1 // åˆå§‹åŒ–äºŒç»´æ•°ç»„çš„ç¬¬0è¡Œæˆ–ç¬¬0åˆ—ç­‰äº1
				continue
			} 
			dp[i][j] = dp[i-1][j] + dp[i][j-1] // æ¯ä¸€æ ¼çš„è·¯å¾„ç”±å…¶ä¸Šä¸€æ ¼å’Œå·¦ä¸€æ ¼å†³å®š
		}
	}
	return dp[m-1][n-1]
}
```


**æ–¹æ³•äºŒï¼šæ»šåŠ¨æ•°ç»„ ä¼˜åŒ–ç©ºé—´ O(n)**

![](images/62-1.png)

- åªç”¨é•¿åº¦ä¸º n çš„åˆ—è¡¨è®°å½•è·¯å¾„ï¼ˆçºµå‘ï¼‰
- å°†è‡ªèº«ä¸ä¸Šä¸€æ ¼ç›¸åŠ å¾—åˆ°å³ä¸€æ ¼



```go
func uniquePaths(m int, n int) int {
	dp := make([]int, n)
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if j == 0 { // åˆå§‹åŒ–ï¼šåˆ°è¾¾èµ·ç‚¹åªæœ‰ä¸€ç§èµ°æ³•
				dp[j] = 1
				continue
			}
			dp[j] += dp[j-1] // å°†è‡ªèº«ä¸ä¸Šä¸€æ ¼ç›¸åŠ å¾—åˆ°å³ä¸€æ ¼
		}
	}
	return dp[n-1]
}
```

[å‚è€ƒå®˜æ–¹è§†é¢‘é¢˜è§£](https://leetcode.cn/problems/unique-paths/solutions/514311/bu-tong-lu-jing-by-leetcode-solution-hzjf/)


## [695. å²›å±¿çš„æœ€å¤§é¢ç§¯](https://leetcode-cn.com/problems/max-area-of-island/)

```go
func maxAreaOfIsland(grid [][]int) int {
	maxArea := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			if grid[i][j] == 1 {
				maxArea = max(maxArea, dfs(grid, i, j))
			}
		}
	}
	return maxArea
}

func dfs(grid [][]int, i, j int) int {
	if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == 0 {
		return 0
	}
	area := 1      // å²›å±¿çš„é¢ç§¯è‡³å°‘ä¸º1
	grid[i][j] = 0 // å·²æ‰«æï¼Œæ ‡è®°ä¸ºæµ·æ´‹ï¼Œé˜²æ­¢é‡å¤æ‰«æ
	area += dfs(grid, i-1, j)
	area += dfs(grid, i+1, j)
	area += dfs(grid, i, j-1)
	area += dfs(grid, i, j+1)
	return area
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

## [227. åŸºæœ¬è®¡ç®—å™¨ II](https://leetcode-cn.com/problems/basic-calculator-ii/)


## [83. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)


## [è¡¥å……é¢˜6. æ‰‹æ’•å †æ’åº 912. æ’åºæ•°ç»„](https://leetcode-cn.com/problems/sort-an-array/)






