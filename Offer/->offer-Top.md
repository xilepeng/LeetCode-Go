CodeTopæ’å

1. [å‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹](#å‰‘æŒ‡-offer-22-é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹)
2. [å‰‘æŒ‡ Offer 09. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—](#å‰‘æŒ‡-offer-09-ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—)
3. [å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨](#å‰‘æŒ‡-offer-36-äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨)
4. [å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹](#å‰‘æŒ‡-offer-54-äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹)
5. [å‰‘æŒ‡ Offer 06. ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨](#å‰‘æŒ‡-offer-06-ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨)
6. [å‰‘æŒ‡ Offer 10- I. æ–æ³¢é‚£å¥‘æ•°åˆ—](#å‰‘æŒ‡-offer-10--i-æ–æ³¢é‚£å¥‘æ•°åˆ—)
7. [å‰‘æŒ‡ Offer 10- II. é’è›™è·³å°é˜¶é—®é¢˜](#å‰‘æŒ‡-offer-10--ii-é’è›™è·³å°é˜¶é—®é¢˜)
8. [å‰‘æŒ‡ Offer 30. åŒ…å«minå‡½æ•°çš„æ ˆ](#å‰‘æŒ‡-offer-30-åŒ…å«minå‡½æ•°çš„æ ˆ)
9. [å‰‘æŒ‡ Offer 04. äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾](#å‰‘æŒ‡-offer-04-äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾)
10. [å‰‘æŒ‡ Offer 42. è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ](#å‰‘æŒ‡-offer-42-è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ)
11. [å‰‘æŒ‡ Offer 51. æ•°ç»„ä¸­çš„é€†åºå¯¹](#å‰‘æŒ‡-offer-51-æ•°ç»„ä¸­çš„é€†åºå¯¹)
12. [å‰‘æŒ‡ Offer 40. æœ€å°çš„kä¸ªæ•°](#å‰‘æŒ‡-offer-40-æœ€å°çš„kä¸ªæ•°)
13. [å‰‘æŒ‡ Offer 18. åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹](#å‰‘æŒ‡-offer-18-åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹)
14. [å‰‘æŒ‡ Offer 52. ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹](#å‰‘æŒ‡-offer-52-ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹)
15. [å‰‘æŒ‡ Offer 25. åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨](#å‰‘æŒ‡-offer-25-åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨)
16. [å‰‘æŒ‡ Offer 10- I. æ–æ³¢é‚£å¥‘æ•°åˆ—](#å‰‘æŒ‡-offer-10--i-æ–æ³¢é‚£å¥‘æ•°åˆ—-1)
17. [å‰‘æŒ‡ Offer 10- II. é’è›™è·³å°é˜¶é—®é¢˜](#å‰‘æŒ‡-offer-10--ii-é’è›™è·³å°é˜¶é—®é¢˜-1)
18. [å‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²](#å‰‘æŒ‡-offer-48-æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²)
19. [å‰‘æŒ‡ Offer 21. è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢](#å‰‘æŒ‡-offer-21-è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢)
20. [å‰‘æŒ‡ Offer 62. åœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°å­—](#å‰‘æŒ‡-offer-62-åœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°å­—)
21. [å‰‘æŒ‡ Offer 26. æ ‘çš„å­ç»“æ„](#å‰‘æŒ‡-offer-26-æ ‘çš„å­ç»“æ„)
22. [å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ](#å‰‘æŒ‡-offer-27-äºŒå‰æ ‘çš„é•œåƒ)
23. [å‰‘æŒ‡ Offer 29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ](#å‰‘æŒ‡-offer-29-é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ)
24. [å‰‘æŒ‡ Offer 52. ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹](#å‰‘æŒ‡-offer-52-ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹-1)
25. [å‰‘æŒ‡ Offer 61. æ‰‘å…‹ç‰Œä¸­çš„é¡ºå­](#å‰‘æŒ‡-offer-61-æ‰‘å…‹ç‰Œä¸­çš„é¡ºå­)
26. [å‰‘æŒ‡ Offer 39. æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—](#å‰‘æŒ‡-offer-39-æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—)
27. [å‰‘æŒ‡ Offer 45. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°](#å‰‘æŒ‡-offer-45-æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°)
28. [å‰‘æŒ‡ Offer 34. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„](#å‰‘æŒ‡-offer-34-äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„)
29. [å‰‘æŒ‡ Offer 53 - I. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­— I](#å‰‘æŒ‡-offer-53---i-åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­—-i)
30. [å‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²](#å‰‘æŒ‡-offer-48-æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²-1)
31. [å‰‘æŒ‡ Offer 11. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—](#å‰‘æŒ‡-offer-11-æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—)
32. [å‰‘æŒ‡ Offer 33. äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—](#å‰‘æŒ‡-offer-33-äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—)
33. [å‰‘æŒ‡ Offer 03. æ•°ç»„ä¸­é‡å¤çš„æ•°å­—](#å‰‘æŒ‡-offer-03-æ•°ç»„ä¸­é‡å¤çš„æ•°å­—)
34. [å‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III](#å‰‘æŒ‡-offer-32---iii-ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘-iii)
35. [å‰‘æŒ‡ Offer 07. é‡å»ºäºŒå‰æ ‘ ğŸ“](#å‰‘æŒ‡-offer-07-é‡å»ºäºŒå‰æ ‘-)
36. [å‰‘æŒ‡ Offer 35. å¤æ‚é“¾è¡¨çš„å¤åˆ¶ ğŸ“](#å‰‘æŒ‡-offer-35-å¤æ‚é“¾è¡¨çš„å¤åˆ¶-)
37. [å‰‘æŒ‡ Offer 24. åè½¬é“¾è¡¨](#å‰‘æŒ‡-offer-24-åè½¬é“¾è¡¨)



## [å‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getKthFromEnd(head *ListNode, k int) *ListNode {
    slow, fast := head, head
    for fast != nil {
        if k > 0 {
            fast = fast.Next // fast æŒ‡é’ˆå…ˆèµ° k æ­¥
            k--
        } else {
            slow = slow.Next
            fast = fast.Next
        }
    }
    return slow
}

func getKthFromEnd1(head *ListNode, k int) *ListNode {
    slow, fast := head, head
    for i := 0; fast != nil; i++ {
        if i >= k {
            slow = slow.Next
        }
        fast = fast.Next // fast æŒ‡é’ˆå…ˆèµ° k æ­¥
    }
    return slow
}
```


## [å‰‘æŒ‡ Offer 09. ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```go
type CQueue struct {
    inStack,outStack []int 
}

func Constructor() CQueue {
    return CQueue{
    }
}

func (this *CQueue) AppendTail(value int)  {
    this.inStack = append(this.inStack, value)
}

func (this *CQueue) DeleteHead() int {
    if len(this.outStack) == 0 {
        if len(this.inStack) == 0 {
            return -1
        }
        this.in2out()
    }
    head := this.outStack[len(this.outStack)-1]
    this.outStack = this.outStack[:len(this.outStack)-1]
    return head
}

func (this *CQueue) in2out(){
    for len(this.inStack) > 0 {
        this.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])
        this.inStack = this.inStack[:len(this.inStack)-1]
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.AppendTail(value);
 * param_2 := obj.DeleteHead();
 */
```


## [å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/)

```go
package main

import "fmt"

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

var head, prev *TreeNode // head å¤´ prev å°¾

// äºŒå‰æœç´¢æ ‘è½¬åŒå‘å¾ªç¯é“¾è¡¨
func treeToDoublyList(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	dfs(root)
	// é¦–å°¾ç›¸è¿ä½¿å…¶æˆä¸ºåŒå‘å¾ªç¯é“¾è¡¨  head->1<->2<->3<->4<->5<-pre    head<->prev
	prev.Right = head // å°¾æŒ‡å‘å¤´
	head.Left = prev  // å¤´æŒ‡å‘å°¾
	return head
}

// ä¸­åºéå†: å·¦æ ¹å³
func dfs(curr *TreeNode) {
	if curr == nil {
		return
	}
	dfs(curr.Left)   // é€’å½’å·¦å­æ ‘
	if prev == nil { // è®°å½•å¤´èŠ‚ç‚¹
		head = curr
	} else { // prev != nil
		prev.Right = curr // ä¿®æ”¹å•å‘ -> èŠ‚ç‚¹å¼•ç”¨ä¸ºåŒå‘ <->ï¼ˆåŒå‘å¾ªç¯é“¾è¡¨ï¼‰
		curr.Left = prev
	}
	prev = curr     // æ»šåŠ¨æ‰«æä¸‹ä¸€ä¸ªèŠ‚ç‚¹
	dfs(curr.Right) // é€’å½’å³å­æ ‘
}

func main() {
	// æ„é€ äºŒå‰æœç´¢æ ‘
	root := &TreeNode{4, nil, nil}
	node1 := &TreeNode{2, nil, nil}
	node2 := &TreeNode{5, nil, nil}
	node3 := &TreeNode{1, nil, nil}
	node4 := &TreeNode{3, nil, nil}
	root.Left = node1
	root.Right = node2
	node1.Left = node3
	node1.Right = node4

	head := treeToDoublyList(root)
	tail := head.Left

	fmt.Println("ä»å¤´å¼€å§‹éå†:")
	for i := 0; i <= 9; i++ {
		fmt.Printf(" <-> %d", head.Val)
		head = head.Right
	}
	fmt.Println("\nä»å°¾å¼€å§‹éå†:")
	for i := 0; i <= 9; i++ {
		fmt.Printf(" <-> %d", tail.Val)
		tail = tail.Left
	}

}

//ä»å¤´å¼€å§‹éå†:
//<-> 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 1 <-> 2 <-> 3 <-> 4 <-> 5
//ä»å°¾å¼€å§‹éå†:
//<-> 5 <-> 4 <-> 3 <-> 2 <-> 1 <-> 5 <-> 4 <-> 3 <-> 2 <-> 1

```




## [å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)



```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func kthLargest(root *TreeNode, k int) (res int) {
    var dfs func(*TreeNode)

    dfs = func(root *TreeNode) {
        if root == nil {
            return
        }
        dfs(root.Right)
        k--
        if k == 0 { res = root.Val}
        dfs(root.Left) 
    }
    
    dfs(root)
    return res
}
```




## [å‰‘æŒ‡ Offer 06. ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reversePrint(head *ListNode) []int {
    res := []int{}
    head = reverseList(head)
    for ; head != nil; head = head.Next {
        res = append(res, head.Val)
    }
    return res
}

func reverseList(head *ListNode) *ListNode{
    dummy := &ListNode{Next:head}
    curr := head
    for curr != nil && curr.Next != nil {
        next := curr.Next
        curr.Next = next.Next
        next.Next = dummy.Next
        dummy.Next = next
    }
    return dummy.Next
}

```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reversePrint(head *ListNode) (res []int) {
    if head == nil {
        return 
    }
    res = reversePrint(head.Next)
    res = append(res, head.Val)
    return 
}
func reversePrint1(head *ListNode) (res []int) {
    stack := []int{}
    for ; head != nil; head=head.Next {
        stack = append(stack, head.Val)
    }
    for i := len(stack)-1; i >= 0; i-- {
        res = append(res, stack[i])
    }
    return
}
```




## [å‰‘æŒ‡ Offer 10- I. æ–æ³¢é‚£å¥‘æ•°åˆ—](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)



```go
func fib(n int) int {
    prev, curr := 0, 1 
    for ; n > 0; n-- {
        sum := (prev + curr) % 1000000007
        prev = curr
        curr = sum
    }
    return prev
}

func fib1(n int) int {
    if n == 0 || n == 1 {
        return n 
    }
    prev, curr := 0, 1
    for i := 2; i <= n; i++ {
        next := (prev + curr) % 1000000007
        prev = curr
        curr = next
    }
    return curr
}
```



## [å‰‘æŒ‡ Offer 10- II. é’è›™è·³å°é˜¶é—®é¢˜](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

```go
func numWays(n int) int {
	prev, curr := 1, 1
	for ; n > 0; n-- {
		sum := (prev + curr) % 1000000007
		prev = curr
		curr = sum
	}
	return prev
}

func numWays1(n int) int {
    if n == 1 || n == 2 {
        return n 
    }
	prev, curr := 1, 1
	for i := 2; i <= n; i++{
		sum := (prev + curr) % 1000000007
		prev = curr
		curr = sum
	}
	return curr
} 

func numWays2(n int) int {
	prev, curr := 1, 1
	for i := 2; i <= n; i++{
		sum := (prev + curr) % 1000000007
		prev = curr
		curr = sum
	}
	return curr
} 
```



## [å‰‘æŒ‡ Offer 30. åŒ…å«minå‡½æ•°çš„æ ˆ](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)


```go
type MinStack struct {
	stack    []int
	minStack []int
}

/** initialize your data structure here. */
func Constructor() MinStack {
	return MinStack{
		stack:    []int{},
		minStack: []int{math.MaxInt64}, // å•è°ƒæ ˆï¼šå•è°ƒé€’å‡ï¼Œtop å­˜å‚¨æœ€å°å€¼
	}
}

func (this *MinStack) Push(x int) {
	this.stack = append(this.stack, x)
	top := this.minStack[len(this.minStack)-1]
	this.minStack = append(this.minStack, min(top, x))
}

func (this *MinStack) Pop() {
	this.stack = this.stack[:len(this.stack)-1]
	this.minStack = this.minStack[:len(this.minStack)-1]
}

func (this *MinStack) Top() int {
	return this.stack[len(this.stack)-1]
}

func (this *MinStack) Min() int {
	return this.minStack[len(this.minStack)-1]
}

func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.Min();
 */
```

```go
type MinStack struct {
	stack    []int
	minStack []int // å•è°ƒæ ˆï¼šå•è°ƒé€’å‡ï¼Œtop å­˜å‚¨æœ€å°å€¼
}

/** initialize your data structure here. */
func Constructor() MinStack {
	return MinStack{
		nil,
		nil,
	}
}

func (this *MinStack) Push(x int) {
	this.stack = append(this.stack, x)
	if len(this.minStack) == 0 || this.minStack[len(this.minStack)-1] >= x {
		this.minStack = append(this.minStack, x)
	}
}

func (this *MinStack) Pop() {
	if this.minStack[len(this.minStack)-1] == this.stack[len(this.stack)-1] {
		this.minStack = this.minStack[:len(this.minStack)-1]
	}
	this.stack = this.stack[:len(this.stack)-1]
}

func (this *MinStack) Top() int {
	return this.stack[len(this.stack)-1]
}

func (this *MinStack) Min() int {
	return this.minStack[len(this.minStack)-1]
}

/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.Min();
 */
```


## [å‰‘æŒ‡ Offer 04. äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/description/)


```go
func findNumberIn2DArray(matrix [][]int, target int) bool {
    if len(matrix) == 0 {
        return false
    }
    x, y := 0, len(matrix[0])-1
    for x < len(matrix) && y >= 0 {
        if matrix[x][y] == target {
            return true
        }
        if target < matrix[x][y] {
            y--
        } else {
            x++
        }
    }
    return false
}
```





## [å‰‘æŒ‡ Offer 42. è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)


```go
func maxSubArray(nums []int) int {
	max, preSum := math.MinInt32, 0 // max = nums[0] OK
	for _, x := range nums {
		if preSum < 0 {
			preSum = 0
		}
		preSum += x
		if max < preSum {
			max = preSum
		}
	}
	return max
}
```


```go
func maxSubArray(nums []int) int {
	pre, maxSum := 0, nums[0]
	for _, x := range nums {
        // è‹¥å½“å‰æŒ‡é’ˆæ‰€æŒ‡å…ƒç´ ä¹‹å‰çš„å’Œå°äº0ï¼Œåˆ™ä¸¢å¼ƒå½“å‰å…ƒç´ ä¹‹å‰çš„æ•°åˆ—
		pre = max(pre+x, x)       
		maxSum = max(maxSum, pre) // å°†å½“å‰å€¼ä¸æœ€å¤§å€¼æ¯”è¾ƒï¼Œå–æœ€å¤§
	}
	return maxSum
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

```go
func maxSubArray(nums []int) int {
	max := nums[0]
	for i := 1; i < len(nums); i++ {
        // è‹¥å‰ä¸€ä¸ªå…ƒç´ å¤§äº0ï¼Œå°†å…¶åŠ åˆ°å½“å‰å…ƒç´ ä¸Š
		if nums[i-1]+nums[i] > nums[i] { // nums[i-1] > 0  
			nums[i] += nums[i-1]
		}
		if max < nums[i] {
			max = nums[i]
		}
	}
	return max
}
```




## [å‰‘æŒ‡ Offer 51. æ•°ç»„ä¸­çš„é€†åºå¯¹](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)


```go
func reversePairs(nums []int) int {
	return mergeSort(nums, 0, len(nums)-1)
}

func mergeSort(arr []int, start, end int) int {
	if start >= end {
		return 0
	}
	mid := start + (end-start)>>1
	left := mergeSort(arr, start, mid)
	right := mergeSort(arr, mid+1, end)
	cross := merge(arr, start, mid, end)
	return left + right + cross
}

func merge(arr []int, start, mid, end int) int {
	tmpArr := make([]int, end-start+1)
	i, j, k, count := start, mid+1, 0, 0
	for p := start; p <= end; p++ {
		if i > mid {
			tmpArr[k] = arr[j]
			j++
		} else if j > end {
			tmpArr[k] = arr[i]
			i++
		} else if arr[i] <= arr[j] {
			tmpArr[k] = arr[i]
			i++
		} else {
			count += mid - i + 1
			tmpArr[k] = arr[j]
			j++
		}
		k++
	}
	copy(arr[start:end+1], tmpArr)
	return count
}
```




## [å‰‘æŒ‡ Offer 40. æœ€å°çš„kä¸ªæ•°](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/description/)

**1. ç»“æœæ— åº**

```go
func getLeastNumbers(arr []int, k int) []int {
    quickSelect(arr, 0, len(arr)-1, k)
    return arr[:k]
}

func quickSelect(A []int, low, high, k int) {
    if low >= high {
        return
    }
    pos := partition(A, low, high)
    if pos == k {
        return
    } else if pos < k {
        quickSelect(A, pos+1, high, k)
    } else {
        quickSelect(A, low, pos-1, k)
    }
}

func partition(A []int, low, high int) int {
    A[high], A[low+(high-low)>>1] = A[low+(high-low)>>1], A[high] // ä¼˜åŒ–
    i, j := low, high 
    for i < j {
        for i < j && A[i] <= A[high] {
            i++
        }
        for i < j && A[j] >= A[high] {
            j--
        }
        A[i], A[j] = A[j], A[i]
    }
    A[i], A[high] = A[high], A[i]
    return i 
}

func Partition(A []int, low, high int) int {
    i, x := low, A[high]
    for j := low; j < high; j++ {
        if A[j] < x {
            A[i], A[j] = A[j], A[i]
            i++
        }
    }
    A[i], A[high] = A[high], A[i]
    return i
}
```


**2. ç»“æœæœ‰åº**

```go
func getLeastNumbers(A []int, k int) (res []int) {
	heapSize := len(A)
	buildHeap(A, heapSize)
	for i := heapSize - 1; i >= 0; i-- {
		if k == 0 { // ä¼˜åŒ–
			break
		}
		res = append(res, A[0])
		k--
		A[0], A[i] = A[i], A[0]
		heapSize--
		minHeapify(A, 0, heapSize)
	}
	return
}

func buildHeap(A []int, heapSize int) {
	for i := heapSize >> 1; i >= 0; i-- {
		minHeapify(A, i, heapSize)
	}
}

// å°æ ¹å †ï¼šé™åº
func minHeapify(A []int, i, heapSize int) {
	for i<<1+1 < heapSize {
		lson, rson, small := i<<1+1, i<<1+2, i
		for lson < heapSize && A[lson] < A[small] {
			small = lson
		}
		for rson < heapSize && A[rson] < A[small] {
			small = rson
		}
		if small != i {
			A[i], A[small] = A[small], A[i]
			i = small
		} else {
			break
		}
	}
}
```


## [å‰‘æŒ‡ Offer 18. åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteNode(head *ListNode, val int) *ListNode {
	dummy := &ListNode{Next: head}
	prev, curr := dummy, dummy.Next
	for curr != nil{
		if curr.Val == val {
            prev.Next = curr.Next
        } 
        prev = prev.Next
        curr = curr.Next
	}
	return dummy.Next
}
```


## [å‰‘æŒ‡ Offer 52. ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	A, B := headA, headB
	for A != B {
		if A != nil {
			A = A.Next
		} else {
			A = headB
		}
		if B != nil {
			B = B.Next
		} else {
			B = headA
		}
	}
	return A
}
```










## [å‰‘æŒ‡ Offer 25. åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	dummy := &ListNode{}
	prev := dummy
	for l1 != nil && l2 != nil {
		if l1.Val < l2.Val {
			prev.Next = l1
			l1 = l1.Next
		} else {
			prev.Next = l2
			l2 = l2.Next
		}
		prev = prev.Next
	}
	if l1 == nil {
		prev.Next = l2
	} else {
		prev.Next = l1
	}
	return dummy.Next
}

func mergeTwoLists1(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	} else if l2 == nil {
		return l1
	} else if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	} else {
		l2.Next = mergeTwoLists(l1, l2.Next)
		return l2
	}
}
```





## [å‰‘æŒ‡ Offer 10- I. æ–æ³¢é‚£å¥‘æ•°åˆ—](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)



```go
func fib(n int) int {
    prev, curr := 0, 1 
    for ; n > 0; n-- {
        sum := (prev + curr)%1000000007
        prev = curr
        curr = sum
    }
    return prev
}
```


``` go
func fib(n int) int {
    if n == 0 || n == 1 {
        return n 
    }
    prev, curr := 0, 1
    for i := 2; i <= n; i++ {
        next := (prev + curr)%1000000007
        prev = curr
        curr = next
    }
    return curr
}
```



## [å‰‘æŒ‡ Offer 10- II. é’è›™è·³å°é˜¶é—®é¢˜](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

``` go
func numWays(n int) int {
	prev, curr := 1, 1
	for ; n > 0; n-- {
		sum := (prev + curr) % 1000000007
		prev = curr
		curr = sum
	}
	return prev
}


func numWays1(n int) int {
    if n == 1 || n == 2 {
        return n 
    }
	prev, curr := 1, 1
	for i := 2; i <= n; i++{
		sum := (prev + curr) % 1000000007
		prev = curr
		curr = sum
	}
	return curr
} 

func numWays2(n int) int {
	prev, curr := 1, 1
	for i := 2; i <= n; i++{
		sum := (prev + curr) % 1000000007
		prev = curr
		curr = sum
	}
	return curr
} 
```




## [å‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof)

```go
func lengthOfLongestSubstring(s string) int {
	longest, n := 0, len(s)
	freq := make(map[byte]int, n) // å“ˆå¸Œé›†åˆè®°å½•æ¯ä¸ªå­—ç¬¦å‡ºç°æ¬¡æ•°
	for i, j := 0, 0; j < n; j++ {
		freq[s[j]]++         // é¦–æ¬¡å‡ºç°å­˜å…¥å“ˆå¸Œ
		for freq[s[j]] > 1 { // å½“å‰å­—ç¬¦ä¸é¦–å­—ç¬¦é‡å¤
			freq[s[i]]-- // æ”¶ç¼©çª—å£ï¼Œè·³è¿‡é‡å¤é¦–å­—ç¬¦
			i++ 		 // å‘åæ‰«æ
			if freq[s[j]] == 1 { // ä¼˜åŒ–ï¼šå¦‚æœæ— é‡å¤é€€å‡ºå¾ªç¯
				break
			}
		}
		if longest < j-i+1 { // ç»Ÿè®¡æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²
			longest = j - i + 1
		}
	}
	return longest
}
```


## [å‰‘æŒ‡ Offer 21. è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)




```go
func exchange(nums []int) []int {
    n := len(nums)
    for slow, fast := 0, 0; fast < n; fast++ {
        if nums[fast]&1 == 1 { // å¥‡æ•°
            nums[slow], nums[fast] = nums[fast], nums[slow] // å¥‡æ•°äº¤æ¢åˆ°å‰åŠéƒ¨åˆ†
            slow++
        }
    }
    return nums
}
```


**æ–¹æ³•ä¸€ï¼šä¸¤æ¬¡éå†**
æ€è·¯

æ–°å»ºä¸€ä¸ªæ•°ç»„ res ç”¨æ¥ä¿å­˜è°ƒæ•´å®Œæˆçš„æ•°ç»„ã€‚éå†ä¸¤æ¬¡ numsï¼Œç¬¬ä¸€æ¬¡éå†æ—¶æŠŠæ‰€æœ‰å¥‡æ•°ä¾æ¬¡è¿½åŠ åˆ° res ä¸­ï¼Œç¬¬äºŒæ¬¡éå†æ—¶æŠŠæ‰€æœ‰å¶æ•°ä¾æ¬¡è¿½åŠ åˆ° res ä¸­ã€‚

```go
func exchange(nums []int) []int {
    res := make([]int, 0, len(nums))
    for _,num := range nums {
        if num%2 == 1 {
            res = append(res, num)
        }
    }
    for _,num := range nums {
        if num%2 == 0 {
            res = append(res, num)
        }
    }
    return res
}
```

**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n ä¸ºæ•°ç»„ nums çš„é•¿åº¦ã€‚éœ€éå† nums ä¸¤æ¬¡ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚ç»“æœä¸è®¡å…¥ç©ºé—´å¤æ‚åº¦ã€‚


**æ–¹æ³•äºŒï¼šåŒæŒ‡é’ˆ + ä¸€æ¬¡éå†**
```go
func exchange(nums []int) []int {
    n := len(nums)
    res := make([]int, n)
    left, right := 0, n-1
    for _,num := range nums {
        if num%2 == 1 {
            res[left] = num
            left++
        } else {
            res[right] = num
            right--
        }
    }
    return res
}
```
**å¤æ‚åº¦åˆ†æ**

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n ä¸ºæ•°ç»„ nums çš„é•¿åº¦ã€‚éœ€éå† nums 1æ¬¡ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚ç»“æœä¸è®¡å…¥ç©ºé—´å¤æ‚åº¦ã€‚


**æ–¹æ³•ä¸‰ï¼šåŸåœ°äº¤æ¢**
```go
func exchange(nums []int) []int {
    left, right := 0, len(nums)-1
    for left < right {
        for left < right && nums[left]%2 == 1 {
            left++
        }
        for left < right && nums[right]%2 == 0 {
            right--
        }
		if left < right {
            nums[left], nums[right] = nums[right], nums[left]	
			//left++    
			//right--
        }
    }
    return nums
}
```


## [å‰‘æŒ‡ Offer 62. åœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°å­—](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/)

é€’æ¨å…³ç³»ï¼š(æ–° + m) % n

```go
func lastRemaining(n int, m int) int {
	if n == 1 {
		return 0
	}
	return (lastRemaining(n-1, m) + m) % n
}
```

```go
func lastRemaining(n int, m int) int {
	return f(n, m)
}

func f(n int, m int) int {
	if n == 1 {
		return 0
	}
	x := f(n-1, m)
	return (x + m) % n
}
```


## [å‰‘æŒ‡ Offer 26. æ ‘çš„å­ç»“æ„](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSubStructure(A *TreeNode, B *TreeNode) bool {
	if A == nil || B == nil { // çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æ„
		return false
	}
	if isSame(A, B) {
		return true
	}
	return isSubStructure(A.Left, B) || isSubStructure(A.Right, B)
}

func isSame(A *TreeNode, B *TreeNode) bool {
	if B == nil {
		return true
	}
	if A == nil || A.Val != B.Val {
		return false
	}
	return isSame(A.Left, B.Left) && isSame(A.Right, B.Right)
}
```


## [å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/)


![](../å·²å®Œæˆ/2022-LeetCodeé¢˜è§£/images/Howell.png)

**æ€è·¯**ï¼š

- éå†çš„è¿‡ç¨‹ä¸­åè½¬æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­©å­å°±å¯ä»¥è¾¾åˆ°æ•´ä½“åè½¬çš„æ•ˆæœï¼›
- æ³¨æ„ï¼šåªè¦æŠŠæ¯ä¸€ä¸ªç»“ç‚¹çš„å·¦å³å­©å­éƒ½åè½¬ä¸€ä¸‹ï¼Œå°±å¯ä»¥è¾¾åˆ°æ•´ä½“åè½¬çš„æ•ˆæœï¼›
- å‰åºã€ååºã€å±‚åºéƒ½å¯ä»¥ï¼Œä¸­åºä¸å¯ä»¥ï¼Œå› ä¸ºä¸­åºéå†ä¼šæŠŠæŸäº›èŠ‚ç‚¹çš„å­©å­åè½¬2æ¬¡ï¼›

**è§£æ³•ä¸€ï¼šé€’å½’**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func mirrorTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil 
    } // å‰åºéå†ï¼šæ ¹å·¦å³
    root.Left, root.Right = root.Right, root.Left // åè½¬å½“å‰èŠ‚ç‚¹çš„å·¦å³å­©å­èŠ‚ç‚¹ï¼šäº¤æ¢å·¦å³å­©å­èŠ‚ç‚¹
    mirrorTree(root.Left) // åè½¬å·¦å­æ ‘
    mirrorTree(root.Right)// åè½¬å³å­æ ‘
    return root
}
```
    
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func mirrorTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil 
    } // ååºéå†ï¼šå·¦å³æ ¹
    mirrorTree(root.Left) // åè½¬å·¦å­æ ‘
    mirrorTree(root.Right)// åè½¬å³å­æ ‘
    root.Left, root.Right = root.Right, root.Left // åè½¬å½“å‰èŠ‚ç‚¹çš„å·¦å³å­©å­èŠ‚ç‚¹ï¼šäº¤æ¢å·¦å³å­©å­èŠ‚ç‚¹
    return root
}
```

**è§£æ³•äºŒï¼šè¿­ä»£æ³•**

- æ¨¡æ‹Ÿå‰åºéå†

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func mirrorTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    q := []*TreeNode{root}
    for len(q) > 0 {
        node := q[0]
        q = q[1:]
        node.Left, node.Right = node.Right, node.Left // å‰åºéå†ï¼šæ ¹å·¦å³
        if node.Left != nil {
            q = append(q, node.Left)
        }
        if node.Right != nil {
            q = append(q, node.Right)
        }
    }
    return root
}
```

## [å‰‘æŒ‡ Offer 29. é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

```go
func spiralOrder(matrix [][]int) (res []int) {
	if len(matrix) == 0 {
		return
	}
	top, right, bottom, left := 0, len(matrix[0])-1, len(matrix)-1, 0
	for left <= right && top <= bottom { // ä¸€æ¡è¾¹ä»å¤´éå†åˆ°åº• (åŒ…æ‹¬æœ€åä¸€ä¸ªå…ƒç´ )
		for i := left; i <= right; i++ { // ä¸Š
			res = append(res, matrix[top][i])
		}
		top++                            // å››ä¸ªè¾¹ç•ŒåŒæ—¶æ”¶ç¼©ï¼Œè¿›å…¥å†…å±‚
		for i := top; i <= bottom; i++ { // å³
			res = append(res, matrix[i][right])
		}
		right--
		if top > bottom || left > right { // é˜²æ­¢é‡å¤éå†
			break
		}
		for i := right; i >= left; i-- { // ä¸‹
			res = append(res, matrix[bottom][i])
		}
		bottom--
		for i := bottom; i >= top; i-- { // å·¦
			res = append(res, matrix[i][left])
		}
		left++
	}
	return
}
```

## [å‰‘æŒ‡ Offer 52. ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	A, B := headA, headB
	for A != B {
		if A != nil {
			A = A.Next
		} else { // é¦–æ¬¡éå†åˆ°å°¾ï¼Œä»¥å¦ä¸€ä¸ªé“¾è¡¨çš„å¤´ä¸ºèµ·ç‚¹ä»å¤´å¼€å§‹éå†
			A = headB
		}
		if B != nil {
			B = B.Next
		} else {
			B = headA
		}
	}
	return A // ç›´åˆ°é“¾è¡¨ç›¸äº¤ A == Bï¼Œé€€å‡ºå¾ªç¯è¿”å›
}
```


## [å‰‘æŒ‡ Offer 61. æ‰‘å…‹ç‰Œä¸­çš„é¡ºå­](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```go
func isStraight(nums []int) bool {
	m := make(map[int]int, 5)
	min, max := 14, 0
	for _, num := range nums {
		if num == 0 { // è·³è¿‡å¤§å°ç‹
			continue
		}
		if num < min { // æœ€å°ç‰Œ
			min = num
		}
		if num > max { // æœ€å¤§ç‰Œ
			max = num
		}
		if _, ok := m[num]; ok { // è‹¥æœ‰é‡å¤ï¼Œæå‰è¿”å› false
			return false
		}
		m[num] = num // æ·»åŠ ç‰Œè‡³ Set
	}
	return max-min < 5 // æœ€å¤§ç‰Œ - æœ€å°ç‰Œ < 5 åˆ™å¯æ„æˆé¡ºå­
}
```



```go
func isStraight(nums []int) bool {
	joker := 0
	sort.Ints(nums) // æ•°ç»„æ’åº
	for i := 0; i < len(nums)-1; i++ {
		if nums[i] == 0 { // ç»Ÿè®¡å¤§å°ç‹æ•°é‡
			joker++
		} else if nums[i] == nums[i+1] { // è‹¥æœ‰é‡å¤ï¼Œæå‰è¿”å› false
			return false
		}
	}
	return nums[4]-nums[joker] < 5 // æœ€å¤§ç‰Œ - æœ€å°ç‰Œ < 5 åˆ™å¯æ„æˆé¡ºå­
}
```


![å‚è€ƒ](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/solutions/212071/mian-shi-ti-61-bu-ke-pai-zhong-de-shun-zi-ji-he-se/)



## [å‰‘æŒ‡ Offer 39. æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)


```go
func majorityElement(nums []int) int {
	res, count := -1, 0
	for _, num := range nums {
		if count == 0 { // å¦‚æœç¥¨æ•°ç­‰äº0ï¼Œé‡æ–°èµ‹å€¼ï¼ŒæŠµæ¶ˆæ‰éä¼—æ•°
			res = num
		}
		if res == num { // å¦‚æœnumå’Œä¼—æ•°resç›¸ç­‰,ç¥¨æ•°è‡ªå¢1
			count++
		} else { // ä¸ç›¸ç­‰,ç¥¨æ•°è‡ªå‡1
			count--
		}
	}
	return res
}
```

```go
func moreThanHalfNum_Solution(nums []int) int {
    major, vote := -1, 0
    for _, x := range nums {
        if vote == 0 {
            major = x 
        }
        if major == x {
            vote++
        } else {
            vote--
        }
    }
    return major
}
```


## [å‰‘æŒ‡ Offer 45. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

```go

func minNumber(nums []int) string {
    // å¿«æ’å®ç°æ’åºï¼Œæ’åºåè½¬æˆstring
	res := make([]string, len(nums))
	for i, v := range nums {
		res[i] = strconv.Itoa(v)
	}
	compare := func(str1, str2 string) bool {
		nums1, _ := strconv.Atoi(str1 + str2)
		nums2, _ := strconv.Atoi(str2 + str1)
		if nums1 < nums2 {
			return true
		}
		return false
	}
	var quickSort func([]string, int, int)

	quickSort = func(strArr []string, low, high int) {
		if low > high {
			return
		}
		i, j := low, len(strArr)-1
		pivot := strArr[high]
		for i < j {
			for i < j && compare(strArr[i], pivot) {
				i++
			}
			for i < j && !compare(strArr[j], pivot) {
				j--
			}
			strArr[i], strArr[j] = strArr[j], strArr[i]
		}
		strArr[i], strArr[high] = strArr[high], strArr[i]

		quickSort(strArr, low, i-1)
		quickSort(strArr, i+1, high)
	}

	quickSort(res, 0, len(res)-1)

	ans := ""
	for _, s := range res {
		ans += s
	}
	return ans
}
```

![å‚è€ƒé¢˜è§£](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/solutions/190476/mian-shi-ti-45-ba-shu-zu-pai-cheng-zui-xiao-de-s-4/)

ï¼[å‚è€ƒè§†é¢‘](https://www.acwing.com/video/182/)


## [å‰‘æŒ‡ Offer 34. äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, target int) (res [][]int) {
    path := []int{}
    var preorder func(*TreeNode, int)
    
    preorder = func(node *TreeNode, left int) {
        if node == nil {
            return
        }
        left -= node.Val
        path = append(path, node.Val)
        defer func(){path = path[:len(path)-1]}()
        if left == 0 && node.Left == nil && node.Right == nil {
            res = append(res, append([]int(nil), path...))
            return
        }
        preorder(node.Left, left)
        preorder(node.Right, left)
    }

    preorder(root, target)
    return 
}
```

## [å‰‘æŒ‡ Offer 53 - I. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾æ•°å­— I](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/description/)

```go
// äºŒåˆ†æŸ¥æ‰¾ target å’Œ targetâˆ’1 çš„å³è¾¹ç•Œï¼Œå°†ä¸¤ç»“æœç›¸å‡å¹¶è¿”å›å³å¯ã€‚
func search(nums []int, target int) int {
	var searchFirstGreaterElement func(int) int // ç¬¬ä¸€ä¸ªå¤§äº targetçš„æ•°çš„ä¸‹æ ‡
	searchFirstGreaterElement = func(target int) int {
		low, high := 0, len(nums)-1
		for low <= high {
			mid := low + ((high - low) >> 1)
			if nums[mid] <= target {
				low = mid + 1
			} else {
				high = mid - 1
			}
		}
		return low
	}
	return searchFirstGreaterElement(target) - searchFirstGreaterElement(target-1)
}
```

![å‚è€ƒ](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solutions/155893/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/)


## [å‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

```go
func lengthOfLongestSubstring(s string) int {
	longest, n := 0, len(s)
	freq := make(map[byte]int, n) // å“ˆå¸Œé›†åˆè®°å½•æ¯ä¸ªå­—ç¬¦å‡ºç°æ¬¡æ•°
	for i, j := 0, 0; j < n; j++ {
		freq[s[j]]++         // é¦–æ¬¡å‡ºç°å­˜å…¥å“ˆå¸Œ
		for freq[s[j]] > 1 { // å½“å‰å­—ç¬¦ä¸é¦–å­—ç¬¦é‡å¤
			freq[s[i]]-- // æ”¶ç¼©çª—å£ï¼Œè·³è¿‡é‡å¤é¦–å­—ç¬¦
			i++ 		 // å‘åæ‰«æ
			if freq[s[j]] == 1 { // ä¼˜åŒ–ï¼šå¦‚æœæ— é‡å¤é€€å‡ºå¾ªç¯
				break
			}
		}
		if longest < j-i+1 { // ç»Ÿè®¡æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²
			longest = j - i + 1
		}
	}
	return longest
}
```



## [å‰‘æŒ‡ Offer 11. æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/description/)

```go
func minArray(nums []int) int {
	low, high := 0, len(nums)-1
	for low < high {
		mid := low + ((high - low) >> 1) // mid = (low + high)/2
		if nums[mid] < nums[high] {      // mid åœ¨å³æ’åºåŒºï¼Œæ—‹è½¬ç‚¹åœ¨[low, mid]
			high = mid
		} else if nums[mid] > nums[high] { // mid åœ¨å·¦æ’åºåŒºï¼Œæ—‹è½¬ç‚¹åœ¨[mid+1, high]
			low = mid + 1
		} else { // æ— æ³•åˆ¤æ–­ mid åœ¨å“ªä¸ªæ’åºæ•°ç»„ä¸­
			high--
		}
	}
	return nums[low]
}
```


## [å‰‘æŒ‡ Offer 33. äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/)


```go
func verifyPostorder(postorder []int) bool {
    var dfs func(int, int) bool

    dfs = func(i, j int)bool {
        if i >= j {   // æ•°ç»„ä¸­å…ƒç´ æœ€å¤šåªæœ‰ä¸€ä¸ª
            return true
        }
        left := i     // å·¦å­æ ‘ä¸‹æ ‡
        for postorder[left] < postorder[j] { // postorder[i:right-1] < æ ¹èŠ‚ç‚¹çš„å€¼ 
            left++
        }
        right := left // å³å­æ ‘ä¸‹æ ‡
        for postorder[right] > postorder[j] { // postorder[right:j-1] > æ ¹èŠ‚ç‚¹çš„å€¼ 
            right++
        }
        return right == j && dfs(i, right-1) && dfs(right, j-1) // é€’å½’åˆ¤æ–­å·¦å³å­æ ‘
    }

    return dfs(0, len(postorder)-1)
}



func verifyPostorder2(postorder []int) bool {
    var dfs func(int, int) bool

    dfs = func(i, j int)bool {
        if i >= j {   // æ•°ç»„ä¸­å…ƒç´ æœ€å¤šåªæœ‰ä¸€ä¸ª
            return true
        }
        pos := i     // å·¦å­æ ‘ä¸‹æ ‡
        for postorder[pos] < postorder[j] {     // postorder[i:pos-1] < æ ¹èŠ‚ç‚¹çš„å€¼ 
            pos++
        }
        for right := pos ; right < j; right++ {  // pos å³å­æ ‘ä¸‹æ ‡
            if postorder[right] < postorder[j] { // postorder[pos:j-1] > æ ¹èŠ‚ç‚¹çš„å€¼ 
                return false
            }
        }
        return dfs(i, pos-1) && dfs(pos, j-1) // é€’å½’åˆ¤æ–­å·¦å³å­æ ‘
    }

    return dfs(0, len(postorder)-1)
}
```





## [å‰‘æŒ‡ Offer 03. æ•°ç»„ä¸­é‡å¤çš„æ•°å­—](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)



**è§£æ³•ä¸€ï¼šåŸåœ°äº¤æ¢**

æ€è·¯ï¼šæŠŠæ¯ä¸ªæ•°æ”¾åˆ°å¯¹åº”çš„ä½ç½®ä¸Šï¼Œå³è®© nums[i] = iã€‚
ä»å‰å¾€åéå†æ•°ç»„ä¸­çš„æ‰€æœ‰æ•°ï¼Œå‡è®¾å½“å‰éå†åˆ°çš„æ•°æ˜¯ nums[i]ï¼Œé‚£ä¹ˆï¼š

- å¦‚æœ nums[i] != i && nums[nums[i]] == nums[i]ï¼Œåˆ™è¯´æ˜ nums[i] å‡ºç°äº†å¤šæ¬¡ï¼Œç›´æ¥è¿”å› nums[i] å³å¯ï¼›
- å¦‚æœ nums[nums[i]] != nums[i]ï¼Œé‚£æˆ‘ä»¬å°±æŠŠ x äº¤æ¢åˆ°æ­£ç¡®çš„ä½ç½®ä¸Šï¼Œå³ swap(nums[nums[i]], nums[i])ï¼Œæ¯æ¬¡swapæ“ä½œéƒ½ä¼šå°†ä¸€ä¸ªæ•°æ”¾åœ¨æ­£ç¡®çš„ä½ç½®ä¸Šï¼Œ
- äº¤æ¢å®Œä¹‹åå¦‚æœnums[i] != iï¼Œåˆ™é‡å¤è¿›è¡Œè¯¥æ“ä½œã€‚ç”±äºæ¯æ¬¡äº¤æ¢éƒ½ä¼šå°†ä¸€ä¸ªæ•°æ”¾åœ¨æ­£ç¡®çš„ä½ç½®ä¸Šï¼Œæ‰€ä»¥swapæ“ä½œæœ€å¤šä¼šè¿›è¡Œ n æ¬¡ï¼Œä¸ä¼šå‘ç”Ÿæ­»å¾ªç¯ã€‚
å¾ªç¯ç»“æŸåï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•é‡å¤çš„æ•°ï¼Œåˆ™è¿”å›-1ã€‚

```go
func findRepeatNumber(nums []int) int {
	for i := range nums {
		for nums[nums[i]] != nums[i] { // å¦‚æœ nums[i] ä¸åœ¨ nums[i] ä½ç½®
			nums[nums[i]], nums[i] = nums[i], nums[nums[i]] // æ¯æ¬¡swapæ“ä½œéƒ½ä¼šå°†ä¸€ä¸ªæ•°æ”¾åœ¨æ­£ç¡®çš„ä½ç½®ä¸Š
		}
		if nums[i] != i { // å¦‚æœå‡ºç°é‡å¤ï¼Œç›´æ¥è¿”å›
			return nums[i]
		}
	}
	return -1
}
```


**è§£æ³•äºŒï¼šåŸåœ°äº¤æ¢**

```go
func findRepeatNumber(nums []int) int {
	for i := 0; i < len(nums); {
		if nums[i] == i { // æ­¤æ•°å­—å·²åœ¨å¯¹åº”ç´¢å¼•ä½ç½®ï¼Œæ— éœ€äº¤æ¢ï¼Œå› æ­¤è·³è¿‡
			i++
			continue
		}
		if nums[nums[i]] == nums[i] { // é‡å¤ï¼šç´¢å¼• nums[i] å¤„å’Œç´¢å¼• i å¤„çš„å…ƒç´ å€¼éƒ½ä¸º nums[i]
			return nums[i]            // å³æ‰¾åˆ°ä¸€ç»„é‡å¤å€¼ï¼Œè¿”å›æ­¤å€¼ nums[i]
		}
		nums[nums[i]], nums[i] = nums[i], nums[nums[i]] // å°†æ­¤æ•°å­—äº¤æ¢è‡³å¯¹åº”ç´¢å¼•ä½ç½®
	}
	return -1
}
```

[å‚è€ƒ](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solutions/96623/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/)






## [å‰‘æŒ‡ Offer 32 - III. ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘ III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) (res [][]int) {
    var bfs func(*TreeNode, int)

    bfs = func(node *TreeNode, level int) {
        if node == nil {
            return 
        }
        if level == len(res) {
            res = append(res, []int{})
        }
        if level%2 == 0 { // ç¬¬ä¸€å±‚æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°
            res[level] = append(res[level],node.Val )
        } else {          // ç¬¬äºŒå±‚æŒ‰ç…§ä»å³åˆ°å·¦çš„é¡ºåºæ‰“å°
            res[level] = append([]int{node.Val}, res[level]...)
        }
        bfs(node.Left, level+1)
        bfs(node.Right, level+1)
    }
    bfs(root, 0)
    return
}
```


## [å‰‘æŒ‡ Offer 07. é‡å»ºäºŒå‰æ ‘](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/) ğŸ“


```go

```


## [å‰‘æŒ‡ Offer 35. å¤æ‚é“¾è¡¨çš„å¤åˆ¶](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/) ğŸ“

```go

```





## [å‰‘æŒ‡ Offer 24. åè½¬é“¾è¡¨](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode{
    dummy := &ListNode{Next:head}
    curr := head
    for curr != nil && curr.Next != nil {
        next := curr.Next
        curr.Next = next.Next
        next.Next = dummy.Next
        dummy.Next = next
    }
    return dummy.Next
}

func reverseList1(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```




