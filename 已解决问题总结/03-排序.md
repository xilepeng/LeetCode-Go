

1. [âœ…æ‰‹æ’•å¿«é€Ÿæ’åº](#æ‰‹æ’•å¿«é€Ÿæ’åº)
2. [âœ…æ‰‹æ’•å½’å¹¶æ’åº](#æ‰‹æ’•å½’å¹¶æ’åº)
3. [âœ…æ‰‹æ’•å †æ’åº](#æ‰‹æ’•å †æ’åº)
4. [ğŸ“æ’å…¥æ’åº](#æ’å…¥æ’åº)
5. [ğŸ“å¸Œå°”æ’åº](#å¸Œå°”æ’åº)
6. [ğŸ“é€‰æ‹©æ’åº](#é€‰æ‹©æ’åº)
7. [ğŸ“å†’æ³¡æ’åº](#å†’æ³¡æ’åº)
8. [Counting Sort](#counting-sort)
9. [Bucket Sort](#bucket-sort)
10. [Radix Sort](#radix-sort)




## [âœ…æ‰‹æ’•å¿«é€Ÿæ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

**1.ä¼˜é›…å†™æ³•**

```go
func sorttmpArray(A []int) []int {
	quickSort(A, 0, len(A)-1)
	return A
}

// å¿«é€Ÿæ’åº O(nlogn) æ˜¯ä¸€ç§åŸºäºâ€œåˆ†æ²»æ€æƒ³â€çš„æ’åºç®—æ³• 
// 1. é€‰å–æ•°ç»„æŸä¸ªå…ƒç´ ä¸ºåŸºå‡†æ•°ï¼Œ
// 2. å°†æ‰€æœ‰å°äºåŸºå‡†æ•°çš„å…ƒç´ ç§»åŠ¨è‡³å…¶å·¦è¾¹ï¼Œå¤§äºåŸºå‡†æ•°çš„å…ƒç´ ç§»åŠ¨è‡³å…¶å³è¾¹,
// 3. é€’å½’å¤„ç†å·¦å³ä¸¤è¾¹ã€‚
func quickSort(A []int, low, high int) {
	if low >= high {
		return
	}
	pos := partition(A, low, high)
	quickSort(A, low, pos-1)
	quickSort(A, pos+1, high)
}

func partition(A []int, low, high int) int {
	A[high], A[low+(high-low)>>1] = A[low+(high-low)>>1], A[high] // ä»¥ A[high] ä½œä¸ºåŸºå‡†æ•°
	i, j := low, high
	for i < j {
		for i < j && A[i] <= A[high] { // ä»å·¦å‘å³æ‰¾é¦–ä¸ªå¤§äºåŸºå‡†æ•°çš„å…ƒç´ 
			i++
		}
		for i < j && A[j] >= A[high] { // ä»å³å‘å·¦æ‰¾é¦–ä¸ªå°äºåŸºå‡†æ•°çš„å…ƒç´ 
			j--
		}
		A[i], A[j] = A[j], A[i] // å…ƒç´ äº¤æ¢åˆ°æ­£ç¡®çš„åŒºé—´
	}
	A[i], A[high] = A[high], A[i] // å°†åŸºå‡†æ•°äº¤æ¢è‡³ä¸¤å­æ•°ç»„çš„åˆ†ç•Œçº¿
	return i                      // è¿”å›åŸºå‡†æ•°çš„ç´¢å¼•
}

// å¿«é€Ÿæ’åºï¼ˆå°¾é€’å½’ä¼˜åŒ–ï¼‰
func quickSort(A []int, low, high int) {
	for low < high { // å­æ•°ç»„é•¿åº¦ä¸º 1 æ—¶ç»ˆæ­¢
		pos := partition(A, low, high) // å“¨å…µåˆ’åˆ†æ“ä½œ
		// å¯¹ä¸¤ä¸ªå­æ•°ç»„ä¸­è¾ƒçŸ­çš„é‚£ä¸ªæ‰§è¡Œå¿«æ’
		if pos-low < high-pos {
			quickSort(A, low, pos-1) // é€’å½’æ’åºå·¦å­æ•°ç»„
			low = pos + 1            // å‰©ä½™å¾…æ’åºåŒºé—´ä¸º [pos + 1, high]
		} else {
			quickSort(A, pos+1, high) // é€’å½’æ’åºå³å­æ•°ç»„
			high = pos - 1            // å‰©ä½™å¾…æ’åºåŒºé—´ä¸º [low, pos - 1]
		}
	}
}
```


*2.æ›´å¿«å†™æ³•*

```go
func sorttmpArray(A []int) []int {
	quickSort(A, 0, len(A)-1)
	return A
}



// å¿«é€Ÿæ’åº O(nlogn) æ˜¯ä¸€ç§åŸºäºâ€œåˆ†æ²»æ€æƒ³â€çš„æ’åºç®—æ³• 
// 1. é€‰å–æ•°ç»„æŸä¸ªå…ƒç´ ä¸ºåŸºå‡†æ•°ï¼Œ
// 2. å°†æ‰€æœ‰å°äºåŸºå‡†æ•°çš„å…ƒç´ ç§»åŠ¨è‡³å…¶å·¦è¾¹ï¼Œå¤§äºåŸºå‡†æ•°çš„å…ƒç´ ç§»åŠ¨è‡³å…¶å³è¾¹,
// 3. é€’å½’å¤„ç†å·¦å³ä¸¤è¾¹ã€‚
func quickSort(A []int, low, high int) {
	if low >= high {
		return
	}
	j := partition(A, low, high)
	quickSort(A, low, j)
	quickSort(A, j+1, high)
}


func partition(A []int, low, high int) int {
	pivot := A[low+(high-low)>>1]
	i, j := low-1, high+1
	for i < j {
		for {
			i++
			if A[i] >= pivot {
				break
			}
		}
		for {
			j--
			if A[j] <= pivot {
				break
			}
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	return j
}

func Partition(A []int, low, high int) int {
	pivot := A[low+(high-low)>>1]
	i, j := low-1, high+1
	for i < j {
		for i++; A[i] < pivot; i++ {
		}
		for j--; A[j] > pivot; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	return j
}
```



## [âœ…æ‰‹æ’•å½’å¹¶æ’åº](https://leetcode.cn/problems/sort-an-tmparray/)

```go
func sorttmpArray(A []int) []int {
	mergeSort(A, 0, len(A)-1)
	return A
}


//ã€Œå½’å¹¶æ’åº Merge Sortã€æ˜¯ç®—æ³•ä¸­â€œåˆ†æ²»æ€æƒ³â€çš„å…¸å‹ä½“ç°ï¼Œå…¶æœ‰ã€Œåˆ’åˆ†ã€å’Œã€Œåˆå¹¶ã€ä¸¤ä¸ªé˜¶æ®µï¼š

// 1. åˆ’åˆ†é˜¶æ®µï¼šé€šè¿‡é€’å½’ä¸æ–­ å°†æ•°ç»„ä»ä¸­ç‚¹ä½ç½®åˆ’åˆ†å¼€ï¼Œå°†é•¿æ•°ç»„çš„æ’åºé—®é¢˜è½¬åŒ–ä¸ºçŸ­æ•°ç»„çš„æ’åºé—®é¢˜ï¼›
// 2. åˆå¹¶é˜¶æ®µï¼šåˆ’åˆ†åˆ°å­æ•°ç»„é•¿åº¦ä¸º 1 æ—¶ï¼Œå¼€å§‹å‘ä¸Šåˆå¹¶ï¼Œä¸æ–­å°† å·¦ã€å³ä¸¤ä¸ªçŸ­æ’åºæ•°ç»„ åˆå¹¶ä¸º ä¸€ä¸ªé•¿æ’åºæ•°ç»„ï¼Œç›´è‡³åˆå¹¶è‡³åŸæ•°ç»„æ—¶å®Œæˆæ’åºï¼›
// O(nlogn)
func mergeSort(A []int, low, high int) {
	// ç»ˆæ­¢æ¡ä»¶
	if low >= high { 
		return
	}
	mid := low + (high-low)>>1  
	// åˆ’åˆ†é˜¶æ®µ
	mergeSort(A, low, mid)    
	mergeSort(A, mid+1, high)   
	// åˆå¹¶é˜¶æ®µ
	merge(A, low, mid, high)    

}

/* åˆå¹¶å·¦å­æ•°ç»„å’Œå³å­æ•°ç»„ */
// å·¦å­æ•°ç»„åŒºé—´ [left, mid]
// å³å­æ•°ç»„åŒºé—´ [mid + 1, right]

func merge(A []int, low, mid, high int) {
	tmpArr := make([]int, high-low+1)
	i, j, k := low, mid+1, 0 // i, j åˆ†åˆ«æŒ‡å‘å·¦å­æ•°ç»„ã€å³å­æ•°ç»„çš„é¦–å…ƒç´ 
	for p := low; p <= high; p++ {
		if j > high || (i <= mid && A[i] < A[j]) { // å¦‚æœ â€œå³å­æ•°ç»„å·²å…¨éƒ¨åˆå¹¶å®Œâ€ æˆ– â€œå·¦å­æ•°ç»„å…ƒç´  <= å³å­æ•°ç»„å…ƒç´ â€
			tmpArr[k] = A[i] // é€‰å–å·¦å­æ•°ç»„å…ƒç´ 
			i++			  // æ‰«æä¸‹ä¸€ä¸ªæ•°
		} else {
			tmpArr[k] = A[j]
			j++
		}
		k++
	}
	copy(A[low:high+1], tmpArr)
}


func merge1(A []int, low, mid, high int) {
	tmpArr := make([]int, high-low+1)
	i, j, k := low, mid+1, 0
	for p := low; p <= high; p++ {
		if i > mid { // æ£€æŸ¥ç¬¬ä¸€éƒ¨åˆ†æ˜¯å¦åˆ°è¾¾æœ«å°¾
			tmpArr[k] = A[j]
			j++
		} else if j > high { // æ£€æŸ¥ç¬¬äºŒéƒ¨åˆ†æ˜¯å¦åˆ°è¾¾æœ«å°¾
			tmpArr[k] = A[i]
			i++
		} else if A[i] <= A[j] { // æ£€æŸ¥å“ªä¸€éƒ¨åˆ†æœ‰æ›´å°çš„å…ƒç´ 
			tmpArr[k] = A[i]
			i++
		} else {
			tmpArr[k] = A[j]
			j++
		}
		k++
	}
	for p := 0; p < k; p++ {
		A[low] = tmpArr[p]
		low++
	}
}

func merge2(A []int, low, mid, high int) {
	tmpArr := make([]int, high-low+1)
	i, j, k := low, mid+1, 0
	for i <= mid && j <= high {
		if A[i] < A[j] {
			tmpArr[k] = A[i]
			i++
		} else {
			tmpArr[k] = A[j]
			j++
		}
        k++
}
	for ; i <= mid; i++ {
		tmpArr[k] = A[i]
		k++
	}
	for ; j <= high; j++ {
		tmpArr[k] = A[j]
		k++
	}
	copy(A[low:high+1], tmpArr)
}
```

## [âœ…æ‰‹æ’•å †æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)


**å¤§æ ¹å †ï¼šå‡åº**

```go
func sorttmpArray(A []int) []int {
	heapSort(A)
	return A
}

// åœ¨å¤§æ ¹å †ä¸­ã€æœ€å¤§å…ƒç´ æ€»åœ¨æ ¹ä¸Šï¼Œå †æ’åºä½¿ç”¨å †çš„è¿™ä¸ªå±æ€§è¿›è¡Œæ’åº
func heapSort(A []int) {
	heapSize := len(A)
	buildMaxHeap(A, heapSize)
	for i := heapSize - 1; i >= 0; i-- {
		A[0], A[i] = A[i], A[0]    // äº¤æ¢å †é¡¶å…ƒç´  A[0] ä¸å †åº•å…ƒç´  A[i]ï¼Œæœ€å¤§å€¼ A[0] æ”¾ç½®åœ¨æ•°ç»„æœ«å°¾
		heapSize--                 // åˆ é™¤å †é¡¶å…ƒç´  A[0]
		maxHeapify(A, 0, heapSize) // å †é¡¶å…ƒç´  A[0] å‘ä¸‹è°ƒæ•´
	}
}

// å»ºå † O(n)
func buildMaxHeap(A []int, heapSize int) {
	for i := heapSize >> 1; i >= 0; i-- { // heapSize / 2 åé¢éƒ½æ˜¯å¶å­èŠ‚ç‚¹ï¼Œä¸éœ€è¦å‘ä¸‹è°ƒæ•´
		maxHeapify(A, i, heapSize)
	}
}

// è¿­ä»£: è°ƒæ•´å¤§æ ¹å † O(n)
func maxHeapify(A []int, i, heapSize int) {
	for i<<1+1 < heapSize { // i*2+1
		lson, rson, large := i<<1+1, i<<1+2, i
		if lson < heapSize && A[large] < A[lson] {
			large = lson
		}
		for rson < heapSize && A[large] < A[rson] {
			large = rson
		}
		if large != i {
			A[i], A[large] = A[large], A[i]
			i = large
		} else {
			break
		}
	}
}

// é€’å½’: è°ƒæ•´å¤§æ ¹å † O(nlogn)
func MaxHeapify(A []int, i, heapSize int) {
	lson, rson, largest := i<<1+1, i<<1+2, i     // i*2+1, i*2+2
	if lson < heapSize && A[largest] < A[lson] { // å·¦å„¿å­å­˜åœ¨å¹¶å¤§äºæ ¹
		largest = lson
	}
	if rson < heapSize && A[largest] < A[rson] { // å³å„¿å­å­˜åœ¨å¹¶å¤§äºæ ¹
		largest = rson
	}
	if i != largest { // æ‰¾åˆ°å·¦å³å„¿å­çš„æœ€å¤§å€¼
		A[i], A[largest] = A[largest], A[i] // å †é¡¶è°ƒæ•´ä¸ºæœ€å¤§å€¼
		MaxHeapify(A, largest, heapSize)    // é€’å½’è°ƒæ•´å­æ ‘
	}
}
```


**å°æ ¹å †ï¼šé™åº**
```go
func sorttmpArray(A []int) []int {
	heapSort(A)
	return A
}

func heapSort(A []int) {
	heapSize := len(A)
	buildHeap(A, heapSize)
	for i := heapSize - 1; i >= 0; i-- {
		A[0], A[i] = A[i], A[0]
		heapSize--
		minHeapify(A, 0, heapSize)
	}
}

func buildHeap(A []int, heapSize int) {
	for i := heapSize >> 1; i >= 0; i-- {
		minHeapify(A, i, heapSize)
	}
}

// å°æ ¹å †ï¼šé€†åº
func minHeapify(A []int, i, heapSize int) {
	for i<<1+1 < heapSize {
		lson, rson, small := i<<1+1, i<<1+2, i
		for lson < heapSize && A[lson] < A[small] {
			small = lson
		}
		for rson < heapSize && A[rson] < A[small] {
			small = rson
		}
		if small != i {
			A[i], A[small] = A[small], A[i]
			i = small
		} else {
			break
		}
	}
}

func MinHeapify(A []int, i, heapSize int) {
	lson, rson, small := i<<1+1, i<<1+2, i
	for lson < heapSize && A[small] < A[lson] {
		small = lson
	}
	for rson < heapSize && A[small] < A[rson] {
		small = rson
	}
	if small != i {
		A[i], A[small] = A[small], A[i]
		MinHeapify(A, small, heapSize)
	}
}
```






```go
/*
 * @lc app=leetcode.cn id=912 lang=golang
 *
 * [912] æ’åºæ•°ç»„
 */

// @lc code=low
func sorttmpArray(A []int) []int {
	InsertSort(A)
	SelectionSort(A)
	BubbleSort(A)
	
	return A
}

```

## [ğŸ“æ’å…¥æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

```go
// æ’å…¥æ’åº
// å–æœªæ’åºåŒºé—´ä¸­çš„å…ƒç´ ï¼Œåœ¨å·²æ’åºåŒºé—´ä¸­æ‰¾åˆ°åˆé€‚çš„æ’å…¥ä½ç½®å°†å…¶æ’å…¥ï¼Œå¹¶ä¿è¯å·²æ’åºåŒºé—´æ•°æ®ä¸€ç›´æœ‰åº
func InsertSort(A []int) {
	for i := 0; i < len(A); i++ {
		base, j := A[i], i 
		// å†…å¾ªç¯ï¼šå°† base æ’å…¥åˆ°å·¦è¾¹çš„æ­£ç¡®ä½ç½®
		for; j > 0 && A[j-1] > base; j-- { // å‘å·¦æ‰«æ
			A[j] = A[j-1] // 1. å°† nums[j-1] å‘å³ç§»åŠ¨ä¸€ä½       
		}
		A[j] = base       // 2. å°† base èµ‹å€¼åˆ°æ­£ç¡®ä½ç½®
	}
}

func insertSort(A []int) {
	for i := 1; i < len(A); i++ {
		base, j := A[i], i
		for ; j > 0; j-- {
			if A[j-1] > base {
				A[j] = A[j-1]
			} else {
				break
			}
		}
		A[j] = base
	}
}

func InsertSort1(A []int) {
	for i := 1; i < len(A); i++ {
		base, j := A[i], i-1
		// å†…å¾ªç¯ï¼šå°† base æ’å…¥åˆ°å·¦è¾¹çš„æ­£ç¡®ä½ç½®
		for ; j >= 0 && A[j] > base; j-- { 
			A[j+1] = A[j] // 1. å°† A[j] å‘å³ç§»åŠ¨ä¸€ä½
		}
		A[j+1] = base     // 2. å°† base èµ‹å€¼åˆ°æ­£ç¡®ä½ç½®
	}
}

```

## [ğŸ“å¸Œå°”æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

```go
// å¸Œå°”æ’åº
// å…ˆé€šè¿‡å¸Œå°”å¢é‡é€æ­¥åˆ†ç»„ç²—æ’ï¼Œå†æ’å…¥æ’åº
func ShellSort(A []int, n int) {
	for d := n >> 1; d > 0; d >>= 1 { // å¸Œå°”å¢é‡ d=n/2
		for i := d; i < n; i++ {
			temp, j := A[i], i
			for j >= d && temp < A[j-d] {
				A[j] = A[j-d] // è¾ƒå¤§æ•°å³ç§»ä¸€ä½
				j -= d        // å‘å·¦æœç´¢
			}
			A[j] = temp // æ’å…¥
		}
	}
}

func ShellSort1(A []int, n int) {
	for d := n >> 1; d > 0; d >>= 1 { // å¸Œå°”å¢é‡ d=n/2
		for i := d; i < n; i++ {
			temp, j := A[i], i-d
			for j >= 0 && temp < A[j] {
				A[j+d] = A[j] // è¾ƒå¤§æ•°å³ç§»ä¸€ä½
				j -= d        // å‘å·¦æœç´¢
			}
			A[j+d] = temp // æ’å…¥
		}
	}
}
```


## [ğŸ“é€‰æ‹©æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

```go
// é€‰æ‹©æ’åº(ä¸ç¨³å®š)
// æ¯æ¬¡ä»æœªæ’åºåŒºé—´ä¸­æ‰¾åˆ°æœ€å°çš„å…ƒç´ ï¼Œå°†å…¶æ”¾åˆ°å·²æ’åºåŒºé—´çš„æœ«å°¾ã€‚
func SelectionSort(A []int) {
	for i := 0; i < len(A); i++ {
		minPos := i
		for j := i + 1; j < len(A); j++ {
			if A[j] < A[minPos] {
				minPos = j // æŸ¥æ‰¾æœ€å°å€¼ä¸‹æ ‡
			}
		} // å°†æœ€å°å€¼äº¤æ¢åˆ°æœ‰åºåŒº
		A[i], A[minPos] = A[minPos], A[i]
	}
}
```

## [ğŸ“å†’æ³¡æ’åº](https://leetcode-cn.com/problems/sort-an-tmparray/)

```go
// å†’æ³¡æ’åº
// ä»å‰å¾€åéå†ï¼Œå¦‚æœå‰ä¸€ä¸ªæ•°å¤§äºåä¸€ä¸ªæ•°ï¼Œäº¤æ¢ï¼Œä¸€æ¬¡å†’æ³¡ä¸€ä¸ªå…ƒç´ å·²æ’åºï¼Œé‡å¤næ¬¡ã€‚

func bubbleSort(A []int) {
	// å¤–å¾ªç¯ï¼šå¾…æ’åºå…ƒç´ æ•°é‡ä¸º n-1, n-2, ..., 1
	for i := len(A) - 1; i > 0; i-- {
		// å†…å¾ªç¯ï¼šå†’æ³¡æ“ä½œ
		for j := 0; j < i; j++ {
			if A[j] > A[j+1] {
				// äº¤æ¢ nums[j] ä¸ nums[j + 1]
				A[j], A[j+1] = A[j+1], A[j]
			}
		}
	}
}

func bubbleSort1(A []int) {
	// å¤–å¾ªç¯ï¼šå¾…æ’åºå…ƒç´ æ•°é‡ä¸º n-1, n-2, ..., 1
	for i := len(A) - 1; i > 0; i-- {
		flag := false
		// å†…å¾ªç¯ï¼šå†’æ³¡æ“ä½œ
		for j := 0; j < i; j++ {
			if A[j] > A[j+1] {
				// äº¤æ¢ nums[j] ä¸ nums[j + 1]
				A[j], A[j+1] = A[j+1], A[j]
				flag = true
			}
		}
		if !flag {
			break
		}
	}
}




func BubbleSort(A []int, n int) {
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if A[j] > A[j+1] {
				A[j], A[j+1] = A[j+1], A[j]
			}
		}
	}
}

func BubbleSort1(A []int, n int) {
	if n <= 1 {
		return
	}
	for i := 0; i < n-1; i++ {
		flag := false // æå‰é€€å‡ºå†’æ³¡å¾ªç¯çš„æ ‡å¿—ä½
		for j := 0; j < n-i-1; j++ {
			if A[j] > A[j+1] {
				A[j], A[j+1] = A[j+1], A[j] // äº¤æ¢ç›¸é‚»çš„2ä¸ªå…ƒç´ 
				flag = true                 // è¡¨ç¤ºæœ‰æ•°æ®è¦äº¤æ¢
			}
		}
		if !flag { // æ²¡æœ‰æ•°æ®äº¤æ¢ï¼Œæå‰é€€å‡º
			break
		}
	}
}
```






## [Counting Sort](https://www.hackerearth.com/practice/algorithms/sorting/counting-sort/tutorial/)


```go

// è®¡æ•°æ’åº æ¨¡ç‰ˆ
// æœ€å¤§å€¼æ˜¯kï¼Œæˆ‘ä»¬å°±å¯ä»¥æŠŠæ•°æ®åˆ’åˆ†æˆkä¸ªæ¡¶ã€‚
// æ¯ä¸ªæ¡¶å†…çš„æ•°æ®å€¼éƒ½æ˜¯ç›¸åŒçš„ï¼Œçœæ‰äº†æ¡¶å†…æ’åºçš„æ—¶é—´ã€‚
// [0, N-1]
func CountingSort(A []int) []int {
	// é¦–å…ˆæ‰¾åˆ°æ•°ç»„çš„æœ€å¤§å€¼ K
	K := 0
	for i := 0; i < len(A); i++ {
		if K < A[i] {
			K = A[i]
		}
	}
	// å­˜å‚¨æ•°ç»„ A ä¸­æ¯ä¸ªå…ƒç´ çš„é¢‘ç‡ï¼Œå€¼ä½œä¸ºè¾…åŠ©æ•°ç»„çš„ç´¢å¼•
	Aux := make([]int, K+1)
	for i := 0; i < len(A); i++ {
		Aux[A[i]]++
	}
	j := 0
	for i := 0; i <= K; i++ {
		tmp := Aux[i]
		for ; tmp > 0; tmp-- {
			A[j] = i
			j++
		}
	}
	return A
}

// è®¡æ•°æ’åº1 æ¨¡ç‰ˆ1
func CountingSort1(a []int, n int) {
	if n <= 1 {
		return
	}
	// æŸ¥æ‰¾æ•°ç»„ä¸­æ•°æ®çš„æœ€å¤§å€¼
	var max int = math.MinInt32
	for i := range a {
		if a[i] > max {
			max = a[i]
		}
	}

	c := make([]int, max+1) // ç”³è¯·ä¸€ä¸ªè®¡æ•°æ•°ç»„cï¼Œä¸‹æ ‡å¤§å°[0,max]
	for i := range a {
		c[a[i]]++ // è®¡ç®—æ¯ä¸ªå…ƒç´ çš„ä¸ªæ•°ï¼Œæ”¾å…¥cä¸­
	}
	for i := 1; i <= max; i++ {
		c[i] += c[i-1] // ä¾æ¬¡ç´¯åŠ ,c[i]å­˜å‚¨å°äºç­‰äºiçš„ä¸ªæ•°
	}
	// ä»æ•°ç»„Cä¸­å–å‡ºä¸‹æ ‡ä¸º3çš„å€¼7ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼ŒåŒ…æ‹¬è‡ªå·±åœ¨å†…ï¼Œåˆ†æ•°å°äºç­‰äº3çš„è€ƒç”Ÿæœ‰7ä¸ªï¼Œ
	// ä¹Ÿå°±æ˜¯è¯´3æ˜¯æ•°ç»„Rä¸­çš„ç¬¬7ä¸ªå…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯æ•°ç»„Rä¸­ä¸‹æ ‡ä¸º6çš„ä½ç½®ï¼‰ã€‚
	// å½“3æ”¾å…¥åˆ°æ•°ç»„Rä¸­åï¼Œå°äºç­‰äº3çš„å…ƒç´ å°±åªå‰©ä¸‹äº†6ä¸ªäº†ï¼Œæ‰€ä»¥ç›¸åº”çš„C[3]è¦å‡1ï¼Œå˜æˆ6ã€‚
	r := make([]int, n) // ä¸´æ—¶æ•°ç»„rï¼Œå­˜å‚¨æ’åºä¹‹åçš„ç»“æœ
	for i := n - 1; i >= 0; i-- {
		index := c[a[i]] - 1 //
		r[index] = a[i]
		c[a[i]]--
	}
	copy(a, r)
}

// è®¡æ•°æ’åº å®ä¾‹
// -5 * 104 <= A[i] <= 5 * 104
func counting_sort(A []int) []int {
	K := 1000001          // é¦–å…ˆæ‰¾åˆ°æ•°ç»„ A çš„æœ€å¤§å€¼ K
	Aux := make([]int, K) // è¾…åŠ©æ•°ç»„ Aux å­˜å‚¨æ•°ç»„ A ä¸­æ¯ä¸ªå…ƒç´ çš„é¢‘ç‡ï¼Œå€¼ä½œä¸ºè¾…åŠ©æ•°ç»„çš„ç´¢å¼•
	for i := 0; i < len(A); i++ {
		Aux[A[i]+50000]++ // é˜²æ­¢-50000ä½œä¸ºç´¢å¼•æ—¶ï¼Œä¸‹æ ‡è¶Šç•Œ
	}
	for i, j := 0, 0; i < K; i++ {
		tmp := Aux[i] // ä»å°åˆ°å¤§å–æ•°å­—içš„é¢‘ç‡
		for ; tmp > 0; tmp-- {
			A[j] = i - 50000
			j++
		}
	}
	return A
}
```






## [Bucket Sort](https://www.hackerearth.com/practice/algorithms/sorting/bucket-sort/tutorial/)

```go

// æ¡¶æ’åº

// è·å–å¾…æ’åºæ•°ç»„ä¸­çš„æœ€å¤§å€¼
func getMax(a []int) int {
	max := a[0]
	for i := 1; i < len(a); i++ {
		if a[i] > max {
			max = a[i]
		}
	}
	return max
}

func BucketSort(a []int) {
	num := len(a)
	if num <= 1 {
		return
	}
	max := getMax(a)
	buckets := make([][]int, num) // äºŒç»´åˆ‡ç‰‡

	index := 0
	for i := 0; i < num; i++ {
		index = a[i] * (num - 1) / max // æ¡¶åºå·
		fmt.Println(index)
		buckets[index] = apphigh(buckets[index], a[i]) // åŠ å…¥å¯¹åº”çš„æ¡¶ä¸­
	}

	tmpPos := 0 // æ ‡è®°æ•°ç»„ä½ç½®
	for i := 0; i < num; i++ {
		bucketLen := len(buckets[i])
		if bucketLen > 0 {
			QuickSort(buckets[i], 0, len(buckets[i])-1) // æ¡¶å†…åšå¿«é€Ÿæ’åº
			copy(a[tmpPos:], buckets[i])
			tmpPos += bucketLen
		}
	}

}

// æ¡¶æ’åºç®€å•å®ç°
func BucketSortSimple(source []int) {
	if len(source) <= 1 {
		return
	}
	tmparray := make([]int, getMax(source)+1)
	for i := 0; i < len(source); i++ {
		tmparray[source[i]]++
	}
	fmt.Println(tmparray)
	c := make([]int, 0)
	for i := 0; i < len(tmparray); i++ {
		for tmparray[i] != 0 {
			c = apphigh(c, i)
			tmparray[i]--
		}
	}
	copy(source, c)

}


```


## [Radix Sort](https://www.hackerearth.com/practice/algorithms/sorting/radix-sort/tutorial/)


```go
// åŸºæ•°æ’åº
// ä¾æ¬¡æŒ‰ä¸ªä½ã€åä½ã€ç™¾ä½è¿›è¡Œæ’åº
func RadixSort(A []int, n int) {

}
```


