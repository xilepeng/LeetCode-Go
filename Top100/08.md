
1. [98. éªŒè¯äºŒå‰æœç´¢æ ‘](#98-éªŒè¯äºŒå‰æœç´¢æ ‘)
2. [394. å­—ç¬¦ä¸²è§£ç ](#394-å­—ç¬¦ä¸²è§£ç )
3. [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](#34-åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®)
4. [113. è·¯å¾„æ€»å’Œ II](#113-è·¯å¾„æ€»å’Œ-ii)
5. [240. æœç´¢äºŒç»´çŸ©é˜µ II](#240-æœç´¢äºŒç»´çŸ©é˜µ-ii)
6. [64. æœ€å°è·¯å¾„å’Œ](#64-æœ€å°è·¯å¾„å’Œ)
7. [221. æœ€å¤§æ­£æ–¹å½¢](#221-æœ€å¤§æ­£æ–¹å½¢)
8. [162. å¯»æ‰¾å³°å€¼](#162-å¯»æ‰¾å³°å€¼)
9. [14. æœ€é•¿å…¬å…±å‰ç¼€](#14-æœ€é•¿å…¬å…±å‰ç¼€)
10. [128. æœ€é•¿è¿ç»­åºåˆ—ğŸ–Œ](#128-æœ€é•¿è¿ç»­åºåˆ—)


## [98. éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func helper(root *TreeNode, lower, upper int) bool {
	if root == nil {
		return true
	}
	return lower < root.Val && root.Val < upper &&
		helper(root.Left, lower, root.Val) && helper(root.Right, root.Val, upper)
}

func isValidBST(root *TreeNode) bool {
	return helper(root, math.MinInt64, math.MaxInt64)
}

func helpe2(root *TreeNode, lower, upper int) bool {
	if root == nil {
		return true
	}
	if root.Val <= lower || root.Val >= upper { //  == è§£å†³ [2,2,2] åº”è¿”å›false
		return false
	}
	return helper(root.Left, lower, root.Val) && helper(root.Right, root.Val, upper)
}
```



## [394. å­—ç¬¦ä¸²è§£ç ](https://leetcode.cn/problems/decode-string/)


**å¤–å±‚çš„å…ˆç­‰ç­‰ï¼ŒæŠŠå†…å±‚çš„è§£å†³äº†å†å’Œä½ è¿çº¿**

**æ–¹æ³•1 æ ˆè§£**


- å¤–å±‚çš„è§£ç éœ€è¦ç­‰å¾…å†…å±‚è§£ç çš„ç»“æœã€‚å…ˆæ‰«æçš„å­—ç¬¦è¿˜ç”¨ä¸ä¸Šï¼Œä½†ä¸èƒ½å¿˜äº†å®ƒä»¬ã€‚
- æˆ‘ä»¬å‡†å¤‡ç”±å†…åˆ°å¤–ï¼Œå±‚å±‚è§£å†³[ ]ï¼Œéœ€è¦ä¿æŒå¯¹å­—ç¬¦çš„è®°å¿†ï¼Œäºæ˜¯ç”¨æ ˆã€‚

![](images/394-1.png)

**å…¥æ ˆå’Œå‡ºæ ˆçš„æ—¶æœº**

å…¥æ ˆæ—¶æœºï¼šé‡åˆ°[ã€‚æ„å‘³ç€è¦è§£å†³å†…éƒ¨çš„äººäº†ï¼Œå¤–éƒ¨çš„æ•°å­—å’Œå­—æ¯ï¼Œå»æ ˆé‡Œç­‰ã€‚
- å½“é‡åˆ°[ï¼Œå·²ç»æ‰«æçš„æ•°å­—å°±æ˜¯â€œå€æ•°â€ï¼Œå…¥æ ˆæš‚å­˜
- å½“é‡åˆ°[ï¼Œå·²ç»æ‰«æçš„å­—æ¯ä¹Ÿå…¥æ ˆç­‰å¾…ï¼Œæ‹¬å·é‡Œçš„è§£ç å®Œäº†ï¼Œä¸€èµ·å‚ä¸æ„å»ºå­—ç¬¦ä¸²ã€‚

![](images/394-2.png)

å‡ºæ ˆæ—¶æœºï¼šé‡åˆ°]ã€‚å†…å±‚çš„æ‰«æå®Œäº†ï¼Œæ ˆé¡¶å…ƒç´ å¯ä»¥å‡ºæ ˆäº†ï¼Œå…±åŒå‚ä¸å­ä¸²çš„æ„å»ºã€‚
- æ ˆé¡¶å°±æ˜¯æœ€è¿‘é‡åˆ°çš„â€œå€æ•°â€å’Œå­—æ¯

![](images/394-3.png)



```go
func decodeString(s string) string {
	numStack := []int{}      // å­˜å€æ•°çš„æ ˆ
	strStack := []string{}   // å­˜å¾…æ‹¼æ¥çš„strçš„æ ˆ
	num := 0                 // å€æ•°çš„â€œæ¬è¿å·¥â€
	res := ""                // å­—ç¬¦ä¸²çš„â€œæ¬è¿å·¥â€
	for _, char := range s { // é€å­—ç¬¦æ‰«æ
		if char >= '0' && char <= '9' { // é‡åˆ°æ•°å­—
			n, _ := strconv.Atoi(string(char))
			num = 10*num + n // ç®—å‡ºå€æ•°
		} else if char == '[' { // é‡åˆ° [
			strStack = append(strStack, res) // resä¸²å…¥æ ˆ
			res = ""                         // å…¥æ ˆåæ¸…é›¶
			numStack = append(numStack, num) // å€æ•°numè¿›å…¥æ ˆç­‰å¾…
			num = 0                          // å…¥æ ˆåæ¸…é›¶
		} else if char == ']' { // é‡åˆ° ]ï¼Œä¸¤ä¸ªæ ˆçš„æ ˆé¡¶å‡ºæ ˆ
			count := numStack[len(numStack)-1] // è·å–æ‹·è´æ¬¡æ•°
			numStack = numStack[:len(numStack)-1]
			preStr := strStack[len(strStack)-1]
			strStack = strStack[:len(strStack)-1]
			res = string(preStr) + strings.Repeat(res, count) // æ„å»ºå­ä¸² = å¤–å±‚ + å†…éƒ¨é‡å¤
		} else {
			res += string(char) // é‡åˆ°å­—æ¯ï¼Œè¿½åŠ ç»™resä¸²
		}
	}
	return res
}
```




[å‚è€ƒ](https://leetcode.cn/problems/decode-string/solutions/264879/zhan-de-ji-yi-nei-ceng-de-jie-ma-liao-bie-wang-lia/?languageTags=golang)



## [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)





```go
func searchRange(nums []int, target int) []int {
	start, end := findFirst(nums, target), findLast(nums, target)
	return []int{start, end}
}

func findFirst(nums []int, target int) int {
	low, high, start := 0, len(nums)-1, -1
	for low <= high {
		mid := low + (high-low)>>1
		if nums[mid] >= target {
			high = mid - 1
		} else {
			low = mid + 1
		}
		if nums[mid] == target {
			start = mid
		}
	}
	return start
}

func findLast(nums []int, target int) int {
	low, high, end := 0, len(nums)-1, -1
	for low <= high {
		mid := low + (high-low)>>1
		if nums[mid] <= target {
			low = mid + 1
		} else {
			high = mid - 1
		}
		if nums[mid] == target {
			end = mid
		}
	}
	return end
}
```



```go
func searchRange(nums []int, target int) []int {
	start, end := findFirst(nums, target), findLast(nums, target)
	return []int{start, end}
}
// äºŒåˆ†æŸ¥æ‰¾ç¬¬ä¸€ä¸ªä¸ target ç›¸ç­‰çš„å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(logn)
func findFirst(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + (high-low)>>1
		if nums[mid] < target {
			low = mid + 1
		} else if nums[mid] > target {
			high = mid - 1
		} else {
			if mid == 0 || nums[mid-1] != target { // æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ target ç›¸ç­‰çš„å…ƒç´ 
				return mid
			}
			high = mid - 1
		}
	}
	return -1
}
// äºŒåˆ†æŸ¥æ‰¾æœ€åä¸€ä¸ªä¸ target ç›¸ç­‰çš„å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(logn)
func findLast(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + (high-low)>>1
		if nums[mid] < target {
			low = mid + 1
		} else if nums[mid] > target {
			high = mid - 1
		} else {
			if mid == len(nums)-1 || nums[mid+1] != target { // æ‰¾åˆ°æœ€åä¸€ä¸ªä¸ target ç›¸ç­‰çš„å…ƒç´ 
				return mid
			}
			low = mid + 1
		}
	}
	return -1
}
```


## [113. è·¯å¾„æ€»å’Œ II](https://leetcode-cn.com/problems/path-sum-ii/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) (res [][]int) {
	var dfs func(*TreeNode, int)
	var path []int

	dfs = func(node *TreeNode, left int) {
		if node == nil {
			return
		}
		left -= node.Val
		path = append(path, node.Val)
		defer func() {
			path = path[:len(path)-1]
		}()
		if node.Left == nil && node.Right == nil && left == 0 {
			res = append(res, append([]int(nil), path...))
			return
		}
		dfs(node.Left, left)
		dfs(node.Right, left)
	}

	dfs(root, targetSum)
	return
}
```






## [240. æœç´¢äºŒç»´çŸ©é˜µ II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)


```go
func searchMatrix(matrix [][]int, target int) bool {
	x, y := 0, len(matrix[0])-1 // ä»å³ä¸Šè§’å¼€å§‹éå†
	for y >= 0 && x < len(matrix) {
		if matrix[x][y] == target {
			return true
		}
		if matrix[x][y] > target {
			y--
		} else {
			x++
		}
	}
	return false
}
```



```go
// æš´åŠ›
func searchMatrix(matrix [][]int, target int) bool {
	for _, row := range matrix {
		for _, v := range row {
			if v == target {
				return true
			}
		}
	}
	return false
}
```




## [64. æœ€å°è·¯å¾„å’Œ](https://leetcode-cn.com/problems/minimum-path-sum/)

```go
func minPathSum(grid [][]int) int {
	m, n := len(grid), len(grid[0]) // m è¡Œ n åˆ—
	for i := 1; i < m; i++ {
		grid[i][0] += grid[i-1][0] // ç¬¬0åˆ— ç´¯åŠ å’Œ
	}
	for j := 1; j < n; j++ {
		grid[0][j] += grid[0][j-1] // ç¬¬0è¡Œ ç´¯åŠ å’Œ
	}
	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			grid[i][j] += min(grid[i-1][j], grid[i][j-1]) // æœ€å°è·¯å¾„å’Œ
		}
	}
	return grid[m-1][n-1]
}

```




## [221. æœ€å¤§æ­£æ–¹å½¢](https://leetcode.cn/problems/maximal-square/)

```go
func maximalSquare(matrix [][]byte) int {
	m, n, maxSide := len(matrix), len(matrix[0]), 0
	dp := make([][]int, m+1)
	for i := 0; i < m+1; i++ {
		dp[i] = make([]int, n+1)
	}
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if matrix[i-1][j-1] == '1' {
				dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1
			} else {
				dp[i][j] = 0
			}
			maxSide = max(maxSide, dp[i][j])
		}
	}
	return maxSide * maxSide
}
```


[å‚è€ƒé¢˜è§£](https://leetcode.cn/problems/maximal-square/solutions/234964/zui-da-zheng-fang-xing-by-leetcode-solution/)



## [162. å¯»æ‰¾å³°å€¼](https://leetcode-cn.com/problems/find-peak-element/)

**äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–**

```go
func findPeakElement(nums []int) int {
	low, high := 0, len(nums)-1
	for low < high {
		mid := low + (high-low)>>1
		if nums[mid] > nums[mid+1] { // å¦‚æœ mid è¾ƒå¤§ï¼Œåˆ™å·¦ä¾§å­˜åœ¨å³°å€¼ï¼Œhigh = m
			high = mid
		} else { // å¦‚æœ mid + 1 è¾ƒå¤§ï¼Œåˆ™å³ä¾§å­˜åœ¨å³°å€¼ï¼Œlow = mid + 1
			low = mid + 1
		}
	}
	return low // low == high
}
```


- æ—¶é—´å¤æ‚åº¦ï¼šO(logn)ï¼Œå…¶ä¸­ nnn æ˜¯æ•°ç»„ nums çš„é•¿åº¦ã€‚

- ç©ºé—´å¤æ‚åº¦ï¼šO(1)ã€‚




## [14. æœ€é•¿å…¬å…±å‰ç¼€](https://leetcode-cn.com/problems/longest-common-prefix/)

**æ–¹æ³•ä¸€ï¼šçºµå‘æ‰«æ**
ä»å‰å¾€åéå†æ‰€æœ‰å­—ç¬¦ä¸²çš„æ¯ä¸€åˆ—ï¼Œæ¯”è¾ƒç›¸åŒåˆ—ä¸Šçš„å­—ç¬¦æ˜¯å¦ç›¸åŒï¼Œ
- å¦‚æœç›¸åŒåˆ™ç»§ç»­å¯¹ä¸‹ä¸€åˆ—è¿›è¡Œæ¯”è¾ƒ;
- å¦‚æœä¸ç›¸åŒåˆ™å½“å‰åˆ—ä¸å†å±äºå…¬å…±å‰ç¼€ï¼Œå½“å‰åˆ—ä¹‹å‰çš„éƒ¨åˆ†ä¸ºæœ€é•¿å…¬å…±å‰ç¼€ã€‚

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i := 0; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i == len(strs[j]) || strs[j][i] != strs[0][i] {
                return strs[0][:i]
            }
        }
    }
    return strs[0]
}
```

```go
func longestCommonPrefix(strs []string) string {
	prefix := strs[0]
	for i := 1; i < len(strs); i++ {
		for j := 0; j < len(prefix); j++ {
			if len(strs[i]) <= j || strs[i][j] != prefix[j] {
				prefix = prefix[0:j]
				break // å¦‚æœä¸ä¸­æ–­ï¼Œj++åä¼šè¶Šç•Œ
			}
		}
	}
	return prefix
}
```





## [128. æœ€é•¿è¿ç»­åºåˆ—](https://leetcode-cn.com/problems/longest-consecutive-sequence/)ğŸ–Œ



**æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨**

```go
func longestConsecutive(nums []int) int {
	numSet, longgest := map[int]bool{}, 0
	for _, num := range nums {
		numSet[num] = true // æ ‡è®° nums æ•°ç»„ä¸­æ‰€æœ‰å…ƒç´ éƒ½å­˜åœ¨
	}
	for _, num := range nums {
		if !numSet[num-1] { // å¦‚æœ num æ²¡æœ‰å‰é©±æ•°ï¼ˆå·¦é‚»å±…ï¼‰num-1
			currNum, currLonggest := num, 1
			for numSet[currNum+1] { // æšä¸¾æ•°ç»„ä¸­çš„æ¯ä¸ªæ•° xï¼Œè€ƒè™‘ä»¥å…¶ä¸ºèµ·ç‚¹ï¼Œä¸æ–­å°è¯•åŒ¹é… x+1,x+2,â‹¯ æ˜¯å¦å­˜åœ¨
				currNum++      // æšä¸¾è¿ç»­çš„ä¸‹ä¸€ä¸ªæ•°
				currLonggest++ // å½“å‰æœ€é•¿è¿ç»­é•¿åº¦é€’å¢
			}
			if longgest < currLonggest { // è®¡ç®—æœ€å¤§é•¿åº¦
				longgest = currLonggest
			}
		}
	}
	return longgest
}
```

- æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œå…¶ä¸­ n ä¸ºæ•°ç»„çš„é•¿åº¦ã€‚å…·ä½“åˆ†æå·²åœ¨ä¸Šé¢æ­£æ–‡ä¸­ç»™å‡ºã€‚

- ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚å“ˆå¸Œè¡¨å­˜å‚¨æ•°ç»„ä¸­æ‰€æœ‰çš„æ•°éœ€è¦ O(n) çš„ç©ºé—´ã€‚



[å‚è€ƒåœ°å€](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/276931/zui-chang-lian-xu-xu-lie-by-leetcode-solution/?languageTags=golang)


```go
func longestConsecutive(nums []int) (res int) {
	numSet := make(map[int]bool, len(nums))
	for _, num := range nums {
		numSet[num] = true
	}
	for num, _ := range numSet {
		if !numSet[num-1] {
			x := num + 1
			for numSet[x] {
				x++
			}
			if res < x-num {
				res = x - num
			}
		}
	}
	return
}
```
